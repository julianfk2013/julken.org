<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Number Guessing Game — Revamped</title>
    <style>
        :root {
            --bg: #0f172a;            /* slate-900 */
            --panel: #111827;         /* gray-900 */
            --panel-2: #0b1220;       /* darker */
            --text: #e5e7eb;          /* gray-200 */
            --muted: #9ca3af;         /* gray-400 */
            --primary: #22c55e;       /* green-500 */
            --primary-600: #16a34a;   /* green-600 */
            --accent: #38bdf8;        /* sky-400 */
            --warn: #f59e0b;          /* amber-500 */
            --danger: #ef4444;        /* red-500 */
            --shadow: 0 10px 30px rgba(0,0,0,0.35);
        }

        * { box-sizing: border-box; }
        html, body { height: 100%; }
        body {
            margin: 0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            color: var(--text);
            background:
                radial-gradient(1200px 600px at 10% -10%, #1f2937 0%, transparent 60%),
                radial-gradient(1000px 500px at 110% 10%, #0b1320 0%, transparent 60%),
                linear-gradient(160deg, #0b1020, #0f172a 55%, #0a0f1f);
            display: grid;
            place-items: center;
            padding: 24px;
        }

            /* Animated starfield canvas */
            #bgCanvas { position: fixed; inset: 0; z-index: 0; pointer-events: none; display: block; will-change: transform; }

        .app {
            width: 100%;
            max-width: 880px;
            display: grid;
            grid-template-columns: 1.1fr 0.9fr;
            gap: 16px;
        position: relative;
        z-index: 1;
        }

        @media (max-width: 820px) {
            .app { grid-template-columns: 1fr; max-width: 620px; }
        }

        .card {
            background: linear-gradient(180deg, var(--panel), var(--panel-2));
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 16px;
            box-shadow: var(--shadow);
            overflow: clip;
        }

        .card:hover { box-shadow: 0 12px 38px rgba(34,197,94,0.08), 0 0 0 1px rgba(255,255,255,0.08) inset; }

        .header { padding: 20px 20px 0 20px; }
        .title { margin: 0; font-size: 24px; letter-spacing: 0.5px; position: relative; }
        .title::after { content: ""; position: absolute; left: 0; bottom: -8px; width: 76px; height: 3px; border-radius: 3px; background: linear-gradient(90deg, var(--accent), transparent); opacity: .7; }
        .subtitle { margin: 6px 0 0; color: var(--muted); font-size: 14px; }

        .body { padding: 16px 20px 20px; }
        .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
        .col { display: grid; gap: 10px; }

        .pill {
            display: inline-flex; align-items: center; gap: 10px;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 999px; padding: 8px 12px; font-size: 13px; color: var(--muted);
        }
        .dot { width: 8px; height: 8px; border-radius: 999px; background: var(--accent); display: inline-block; }

        select, input[type="number"], button {
            appearance: none;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.12);
            background: rgba(255,255,255,0.06);
            color: var(--text);
            padding: 10px 12px;
            font-size: 14px;
            outline: none;
            transition: transform .06s ease, background .2s ease, border-color .2s ease;
        }
        select:hover, input:hover, button:hover { border-color: rgba(255,255,255,0.22); }
        select:focus, input:focus { box-shadow: 0 0 0 2px rgba(56,189,248,.25); }

        .btn-primary { background: linear-gradient(180deg, var(--primary), var(--primary-600)); border: 0; color: white; }
        .btn-primary:hover { filter: brightness(1.04); }
        .btn-ghost { background: transparent; }
        .btn-accent { background: linear-gradient(180deg, #38bdf8, #0ea5e9); color: #001018; border: 0; }
        .btn-warn { background: linear-gradient(180deg, #f59e0b, #d97706); border: 0; color: #1b1200; }
        .btn-danger { background: linear-gradient(180deg, #ef4444, #dc2626); border: 0; }
        .btn { cursor: pointer; }
        .btn:active { transform: translateY(1px); }
        .btn:hover { box-shadow: 0 0 0 2px rgba(255,255,255,0.06) inset, 0 10px 18px rgba(0,0,0,0.25); }
        .btn[disabled] { opacity: .5; cursor: not-allowed; }

        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        @media (max-width: 480px) { .grid-2 { grid-template-columns: 1fr; } }

        .feedback {
            min-height: 46px;
            display: grid; align-content: center;
            border-radius: 12px;
            background: rgba(56, 189, 248, 0.08);
            border: 1px solid rgba(56, 189, 248, 0.18);
            padding: 8px 12px;
            color: #c7e9ff;
            font-size: 14px;
        }

            /* Heat gauge under feedback */
            .heatbar { position: relative; height: 10px; border-radius: 999px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.10); overflow: hidden; margin-top: 8px; }
            .heatfill { height: 100%; width: 0%; background: linear-gradient(90deg, #38bdf8, #22c55e, #f59e0b, #ef4444); transition: width .35s ease; }

        .stat {
            display: grid; gap: 4px; padding: 10px; border-radius: 12px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.08);
        }
        .stat .label { color: var(--muted); font-size: 12px; }
        .stat .value { font-size: 18px; }

        .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12); padding: 2px 6px; border-radius: 6px; font-size: 12px; }

        .modal-backdrop {
            position: fixed; inset: 0; display: none; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.55);
            padding: 16px; z-index: 50;
        }
        .modal { max-width: 680px; width: 100%; }
        .modal .body { max-height: 70vh; overflow: auto; }

        .range-badge { font-variant-numeric: tabular-nums; }
    .range-bar { width: 160px; height: 6px; border-radius: 999px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.08); display:inline-block; margin-left:8px; vertical-align:middle; overflow:hidden; }
    .range-fill { width: 0%; height: 100%; background: linear-gradient(90deg, #38bdf8, #22c55e); transition: width .25s ease; }

        .footer-note { color: var(--muted); font-size: 12px; text-align: center; padding-top: 8px; }

            /* Decorative floating orbs background */
            .decor { position: fixed; inset: 0; pointer-events: none; z-index: 0; }
            .decor::before, .decor::after { content: ""; position: absolute; border-radius: 50%; filter: blur(40px); opacity: .5; }
            .decor::before { width: 520px; height: 520px; left: -140px; top: -120px; background: radial-gradient(circle, rgba(56,189,248,.18), transparent 60%); animation: floatA 14s ease-in-out infinite; }
            .decor::after { width: 460px; height: 460px; right: -120px; bottom: -140px; background: radial-gradient(circle, rgba(34,197,94,.16), transparent 60%); animation: floatB 16s ease-in-out infinite; }
            @keyframes floatA { 0%,100% { transform: translate(0,0);} 50% { transform: translate(18px,-14px);} }
            @keyframes floatB { 0%,100% { transform: translate(0,0);} 50% { transform: translate(-16px,20px);} }

            /* Confetti */
            #fxLayer { position: fixed; inset: 0; pointer-events: none; z-index: 2; overflow: hidden; }
            .confetti { position: absolute; width: 8px; height: 12px; opacity: .95; will-change: transform, opacity; }
            @keyframes confettiFall {
                0% { transform: translate3d(var(--x,0), -10px, 0) rotate(0deg); opacity: 1; }
                100% { transform: translate3d(var(--x,0), 110vh, 0) rotate(360deg); opacity: 0; }
            }

            /* Aurora background layer */
            .aurora { position: fixed; inset: -20% -10% 0 -10%; z-index: 0; pointer-events: none; opacity: 0.65; filter: blur(22px) saturate(1.1); mix-blend-mode: screen; }
            .aurora::before, .aurora::after { content:""; position:absolute; inset:auto; border-radius:50%;}
            .aurora::before { width: 60vw; height: 60vw; left: -10vw; top: 10vh; background: radial-gradient(closest-side, rgba(59,130,246,.20), rgba(59,130,246,0) 70%); animation: auroraA 22s ease-in-out infinite alternate; }
            .aurora::after { width: 55vw; height: 55vw; right: -8vw; top: 30vh; background: radial-gradient(closest-side, rgba(236,72,153,.20), rgba(236,72,153,0) 70%); animation: auroraB 26s ease-in-out infinite alternate; }
            @keyframes auroraA { from { transform: translateY(-6vh);} to { transform: translateY(6vh);} }
            @keyframes auroraB { from { transform: translateY(5vh);} to { transform: translateY(-5vh);} }

            /* Toasts */
            .toast { background: rgba(17,24,39,0.85); color: #e5e7eb; border: 1px solid rgba(255,255,255,0.10); border-radius: 10px; padding: 8px 12px; margin-bottom: 8px; box-shadow: 0 10px 24px rgba(0,0,0,0.35); }

            /* Attempts ring (conic progress) */
            .attempts-wrap { display: inline-flex; align-items: center; gap: 8px; }
            .attempts-ring { --deg: 0deg; --ringColor: #22c55e; width: 40px; height: 40px; border-radius: 50%; background: conic-gradient(var(--ringColor) var(--deg), rgba(255,255,255,0.10) 0); display: grid; place-items: center; box-shadow: inset 0 0 0 2px rgba(255,255,255,0.08); }
            .attempts-ring .ring-center { width: 28px; height: 28px; border-radius: 50%; background: rgba(0,0,0,0.35); display: grid; place-items: center; font-size: 12px; color: var(--text); }

            /* Button ripple effect */
            .btn { position: relative; overflow: hidden; }
            .ripple-ink { position: absolute; border-radius: 50%; transform: scale(0); background: rgba(255,255,255,0.35); animation: ripple .6s ease-out forwards; pointer-events: none; }
            @keyframes ripple { to { transform: scale(4); opacity: 0; } }

            /* Feedback animations */
            .shake { animation: shake .4s; }
            @keyframes shake { 10%, 90% { transform: translateX(-1px);} 20%, 80% { transform: translateX(2px);} 30%, 50%, 70% { transform: translateX(-4px);} 40%, 60% { transform: translateX(4px);} }
            .pulse-success { animation: pulseS 0.6s ease-out; }
            @keyframes pulseS { 0% { box-shadow: 0 0 0 0 rgba(34,197,94,0.5);} 100% { box-shadow: 0 0 0 12px rgba(34,197,94,0); } }

            /* Hint pulse when affordable */
            .hint-ready { box-shadow: 0 0 0 0 rgba(245,158,11,0.5); animation: hintPulse 1.6s infinite; }
            @keyframes hintPulse { 0% { box-shadow: 0 0 0 0 rgba(245,158,11,0.5);} 70% { box-shadow: 0 0 0 10px rgba(245,158,11,0);} 100% { box-shadow: 0 0 0 0 rgba(245,158,11,0);} }

            /* Impossible mode aura */
            .mode-impossible .card { box-shadow: 0 0 0 1px rgba(168,85,247,0.35) inset, 0 0 24px rgba(168,85,247,0.18), var(--shadow); }
            /* Extreme mode aura */
            .mode-extreme .card { box-shadow: 0 0 0 1px rgba(236,72,153,0.35) inset, 0 0 28px rgba(236,72,153,0.22), var(--shadow); }
    </style>
</head>
<body>
            <canvas id="bgCanvas"></canvas>
            <div class="decor" aria-hidden="true"></div>
    <a class="homeBtn" href="index.html" aria-label="Home" style="position:fixed; left:10px; top:10px; z-index:80; display:inline-flex; align-items:center; gap:6px; padding:8px 10px; border-radius:10px; background: rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.16); color:#e5e7eb; text-decoration:none; font-weight:700; backdrop-filter: blur(6px);">🏠 Home</a>
    <main class="app" aria-label="Number Guessing Game">
        <!-- Left: Game panel -->
        <section class="card" aria-labelledby="game-title">
            <header class="header">
                <h1 id="game-title" class="title">Number Guessing Game</h1>
                <p class="subtitle">Pick a difficulty, then guess the secret number. Use hints wisely and build your streak.</p>
            </header>
            <div class="body">
                <div class="row" role="group" aria-label="Game setup">
                    <label class="pill" for="difficulty">
                        <span class="dot" aria-hidden="true"></span>
                        Difficulty
                    </label>
                                                        <select id="difficulty" aria-label="Select difficulty">
                                                            <option value="easy">Easy (1–50 • 6 tries)</option>
                                                            <option value="normal" selected>Normal (1–100 • 8 tries)</option>
                                                            <option value="hard">Hard (1–1000 • 12 tries)</option>
                                                            <option value="impossible">Impossible (1–10000 • 20 tries)</option>
                                                            <option value="extreme">Extremely Impossible (1–1,000,000 • 50 tries)</option>
                                                        </select>
                    <label class="pill" for="dailyToggle" title="Seeded game of the day">
                        <input id="dailyToggle" type="checkbox" /> Daily Challenge
                    </label>
                    <button id="startBtn" class="btn btn-primary" aria-pressed="false">Start Game</button>
                    <button id="resetBtn" class="btn btn-ghost" disabled>Reset Round</button>
                    <button id="rulesBtn" class="btn btn-accent" aria-haspopup="dialog" aria-controls="rulesModal">Rules</button>
                    <button id="settingsBtn" class="btn btn-ghost" aria-haspopup="dialog" aria-controls="settingsModal">Settings</button>
                    <button id="achievementsBtn" class="btn btn-ghost" aria-haspopup="dialog" aria-controls="achievementsModal">Achievements</button>
                </div>

                <div class="row" style="margin-top: 10px;">
                    <div class="pill range-badge" aria-live="polite">
                        Range: <span id="rangeLabel">—</span>
                        <div id="rangeBar" class="range-bar" aria-hidden="true"><div id="rangeFill" class="range-fill"></div></div>
                    </div>
                                <div class="pill attempts-wrap" aria-live="polite" title="Attempts remaining">
                                    <div class="attempts-ring" aria-hidden="true"><div class="ring-center"><span id="attemptsMini">—</span></div></div>
                                    Attempts left: <strong id="attemptsLeft">—</strong>
                                </div>
                </div>

                <div class="grid-2" style="margin-top: 12px;" aria-label="Make a guess">
                    <input id="guessInput" type="number" inputmode="numeric" placeholder="Enter your guess" min="1" disabled aria-disabled="true" aria-label="Your guess" />
                    <button id="guessBtn" class="btn btn-primary" disabled>
                        Guess <span class="kbd" aria-hidden="true">Enter</span>
                    </button>
                </div>

                        <div id="feedback" class="feedback" role="status" aria-live="polite" style="margin-top: 12px;">Press Start to begin.
                            <div class="heatbar" aria-hidden="true"><div id="heatfill" class="heatfill"></div></div>
                        </div>

                <div class="row" style="margin-top: 12px;" role="group" aria-label="Hints">
                    <button id="hintParity" class="btn btn-warn" disabled>Hint: Even or Odd (1 token)</button>
                    <button id="hintNarrow" class="btn btn-warn" disabled>Hint: Narrow Range (2 tokens)</button>
                    <button id="hintLastDigit" class="btn btn-warn" disabled>Hint: Last Digit (1 token)</button>
                    <button id="hintDigitSum" class="btn btn-warn" disabled>Hint: Digit Sum (2 tokens)</button>
                </div>

                <div class="footer-note">Hot/Cold feedback appears after each guess. Closer guesses feel hotter.</div>
                <div id="history" class="stat" style="margin-top:10px;">
                    <div class="label">Guess History</div>
                    <div id="historyList" class="value" style="font-size:13px; line-height:1.5;"></div>
                </div>
            </div>
        </section>

        <!-- Right: Stats panel -->
        <aside class="card" aria-labelledby="stats-title">
            <header class="header">
                <h2 id="stats-title" class="title">Stats & Wallet</h2>
                <p class="subtitle">Earn tokens by winning. Spend tokens on hints.</p>
            </header>
            <div class="body">
                <div class="grid-2">
                    <div class="stat"><div class="label">Tokens</div><div class="value" id="tokens">0</div></div>
                    <div class="stat"><div class="label">Current Streak</div><div class="value" id="streak">0</div></div>
                    <div class="stat"><div class="label">Best Streak</div><div class="value" id="bestStreak">0</div></div>
                    <div class="stat"><div class="label">Wins / Games</div><div class="value"><span id="wins">0</span> / <span id="games">0</span></div></div>
                </div>

                <div class="stat" style="margin-top:10px;">
                    <div class="label">Recent Results</div>
                    <canvas id="statsChart" width="400" height="100" style="width:100%; height:100px;"></canvas>
                </div>

                <div class="row" style="margin-top:12px;">
                    <button id="resetStats" class="btn btn-danger">Reset Stats</button>
                    <button id="muteSound" class="btn btn-ghost" aria-pressed="false">Sound: On</button>
                    <button id="shareBtn" class="btn btn-accent">Copy Share</button>
                </div>
            </div>
        </aside>
    </main>
        <div id="fxLayer" aria-hidden="true"></div>
    <div id="toastLayer" aria-live="polite" aria-atomic="true" style="position:fixed; right:12px; top:12px; z-index:60;"></div>
    <div class="aurora" aria-hidden="true"></div>

    <!-- Rules Modal -->
    <div id="rulesModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="rulesTitle" aria-hidden="true">
        <div class="card modal">
            <header class="header">
                <h2 id="rulesTitle" class="title">How to Play</h2>
                <p class="subtitle">Simple rules, skillful play.</p>
            </header>
            <div class="body">
                <ul>
                    <li>Pick a difficulty and press Start. The game chooses a secret number within the shown range.</li>
                    <li>You have a fixed number of attempts to guess it. Each guess tells you if you're too high/low and how hot/cold you are.</li>
                    <li>Win tokens based on attempts left and difficulty. Spend tokens on hints:</li>
                    <ul>
                        <li><strong>Even/Odd (1)</strong>: Tells if the number is even or odd.</li>
                        <li><strong>Narrow Range (2)</strong>: Shrinks the current possible range significantly.</li>
                        <li><strong>Last Digit (1)</strong>: Reveals the last digit of the secret number.</li>
                        <li><strong>Digit Sum (2)</strong>: Reveals the sum of all digits of the secret number.</li>
                    </ul>
                    <li><strong>Daily Challenge</strong>: Toggle to play a seeded game-of-the-day for each difficulty.</li>
                    <li>New ultra mode: <strong>Extremely Impossible</strong> (1–1,000,000 with 50 attempts).</li>
                    <li>Build a win streak for bragging rights and unlock achievements!</li>
                </ul>
                <div class="row" style="margin-top:10px; justify-content:flex-end;">
                    <button id="closeRules" class="btn btn-primary">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="settingsTitle" aria-hidden="true">
        <div class="card modal">
            <header class="header">
                <h2 id="settingsTitle" class="title">Settings</h2>
                <p class="subtitle">Customize visuals and controls.</p>
            </header>
            <div class="body">
                <div class="row" style="margin-bottom:8px; align-items:center;">
                    <label class="pill" for="themeSelect"><span class="dot" aria-hidden="true"></span> Theme</label>
                    <select id="themeSelect" aria-label="Select theme">
                        <option value="galaxy" selected>Galaxy</option>
                        <option value="neon">Neon</option>
                        <option value="solar">Solar</option>
                    </select>
                </div>
                <div class="row" style="margin-bottom:8px; align-items:center;">
                    <label class="pill" for="fxToggle">Background FX</label>
                    <input id="fxToggle" type="checkbox" checked />
                </div>
                <div class="row" style="margin-bottom:8px; align-items:center;">
                    <label class="pill" for="reducedMotionToggle">Reduced Motion</label>
                    <input id="reducedMotionToggle" type="checkbox" />
                </div>
                <div class="row" style="justify-content:flex-end; margin-top:10px;">
                    <button id="closeSettings" class="btn btn-primary">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Achievements Modal -->
    <div id="achievementsModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="achievementsTitle" aria-hidden="true">
        <div class="card modal">
            <header class="header">
                <h2 id="achievementsTitle" class="title">Achievements</h2>
                <p class="subtitle">Milestones you've unlocked.</p>
            </header>
            <div class="body">
                <ul id="achievementsList" style="list-style:none; padding-left:0; display:grid; gap:8px;">
                    <!-- Populated by script -->
                </ul>
                <div class="row" style="justify-content:flex-end; margin-top:10px;">
                    <button id="closeAchievements" class="btn btn-primary">Close</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        (function () {
            'use strict';

            // --- Utilities ---
            const $ = (sel) => document.querySelector(sel);
            const clamp = (n, min, max) => Math.min(Math.max(n, min), max);

            const storage = {
                get(key, fallback) {
                    try { const v = localStorage.getItem(key); return v == null ? fallback : JSON.parse(v); } catch { return fallback; }
                },
                set(key, value) { try { localStorage.setItem(key, JSON.stringify(value)); } catch {} }
            };

            // --- Elements ---
            const els = {
                difficulty: $('#difficulty'),
                startBtn: $('#startBtn'),
                resetBtn: $('#resetBtn'),
                guessInput: $('#guessInput'),
                guessBtn: $('#guessBtn'),
                feedback: $('#feedback'),
                rangeLabel: $('#rangeLabel'),
                attemptsLeft: $('#attemptsLeft'),
                attemptsMini: $('#attemptsMini'),
                attemptsRing: document.querySelector('.attempts-ring'),
                hintParity: $('#hintParity'),
                hintNarrow: $('#hintNarrow'),
                hintLastDigit: $('#hintLastDigit'),
                hintDigitSum: $('#hintDigitSum'),
                tokens: $('#tokens'),
                streak: $('#streak'),
                bestStreak: $('#bestStreak'),
                wins: $('#wins'),
                games: $('#games'),
                resetStats: $('#resetStats'),
                rulesBtn: $('#rulesBtn'),
                rulesModal: $('#rulesModal'),
                closeRules: $('#closeRules'),
                muteSound: $('#muteSound'),
                shareBtn: $('#shareBtn'),
                statsChart: $('#statsChart'),
                rangeFill: $('#rangeFill'),
                heatfill: $('#heatfill'),
                bgCanvas: $('#bgCanvas'),
                dailyToggle: $('#dailyToggle'),
                settingsBtn: $('#settingsBtn'),
                settingsModal: $('#settingsModal'),
                closeSettings: $('#closeSettings'),
                themeSelect: $('#themeSelect'),
                fxToggle: $('#fxToggle'),
                reducedMotionToggle: $('#reducedMotionToggle'),
                achievementsBtn: $('#achievementsBtn'),
                achievementsModal: $('#achievementsModal'),
                closeAchievements: $('#closeAchievements'),
                achievementsList: $('#achievementsList'),
                toastLayer: $('#toastLayer'),
            };

            // --- Game Config ---
                                    const DIFFICULTY = {
                                        easy:   { min: 1, max: 50, tries: 6,  bonus: 1 },
                                        normal: { min: 1, max: 100, tries: 8, bonus: 2 },
                                    hard:   { min: 1, max: 1000, tries: 12, bonus: 4 },
                                    impossible: { min: 1, max: 10000, tries: 20, bonus: 6 },
                                    extreme: { min: 1, max: 1000000, tries: 50, bonus: 10 },
                                    };

            // --- Persistent state ---
            const state = {
                running: false,
                min: 1,
                max: 100,
                secret: 0,
                triesLeft: 0,
                totalTries: 0,
                guesses: [],
                difficulty: 'normal',
                tokens: storage.get('ng_tokens', 0),
                games: storage.get('ng_games', 0),
                wins: storage.get('ng_wins', 0),
                streak: storage.get('ng_streak', 0),
                bestStreak: storage.get('ng_bestStreak', 0),
                soundOn: storage.get('ng_sound', true),
                daily: storage.get('ng_daily', false),
                theme: storage.get('ng_theme', 'galaxy'),
                fxOn: storage.get('ng_fx', true),
                reducedMotion: storage.get('ng_reduced', false),
                achieve: storage.get('ng_achieve', {}),
                results: storage.get('ng_results', []), // recent 30 results: 1 win / 0 loss
            };

            const sfx = {
                coin: new Audio('drive_assets/coin.mp3'),
                play(audio) { try { if (state.soundOn) audio.currentTime = 0, audio.play(); } catch {} }
            };

                    // Expose a cheat in the console: type `cheat` (getter) or call `cheatFn()`
                    function revealSecret() {
                        if (Number.isFinite(state.secret) && state.secret > 0) {
                            console.log('%cCheat: Secret number is ' + state.secret,'color:#22c55e;font-weight:bold');
                            return state.secret;
                        }
                        console.log('%cCheat: Start a game first to have a secret number.','color:#f59e0b');
                        return null;
                    }
                    try { Object.defineProperty(window, 'cheat', { configurable: true, get: revealSecret }); } catch {}
                    window.cheatFn = () => revealSecret();

                    // Ultra top-secret token setter
                    // Usage in console: __JULKEN_ORG__ULTRA_TOP_SECRET_DO_NOT_SHARE__SET_PLAYER_TOKENS_V1__2025_08_10__(1234)
                    const __TOP_SECRET_CMD__ = '__JULKEN_ORG__ULTRA_TOP_SECRET_DO_NOT_SHARE__SET_PLAYER_TOKENS_V1__2025_08_10__';
                    window[__TOP_SECRET_CMD__] = function(amount) {
                        const val = Number(amount);
                        if (!Number.isFinite(val) || val < 0) {
                            console.log('%cToken setter: provide a non-negative number, e.g., ' + __TOP_SECRET_CMD__ + '(250)','color:#f59e0b');
                            return null;
                        }
                        const n = Math.floor(val);
                        state.tokens = clamp(n, 0, 1000000000);
                        persistStats();
                        updateStatsUI();
                        updateGameUI();
                        console.log('%cTokens set to ' + state.tokens,'color:#22c55e;font-weight:bold');
                        return state.tokens;
                    };

                    // Short no-parentheses setter: use `t$ = 1234` to set tokens, and `t$` to read current tokens
                    try {
                        Object.defineProperty(window, 't$', {
                            configurable: true,
                            get() {
                                console.log('%ct$: assign a number to set tokens (e.g., t$ = 500). Current tokens: ' + state.tokens, 'color:#38bdf8');
                                return state.tokens;
                            },
                            set(amount) {
                                const val = Number(amount);
                                if (!Number.isFinite(val) || val < 0) {
                                    console.log('%cProvide a non-negative number (e.g., t$ = 250).','color:#f59e0b');
                                    return;
                                }
                                state.tokens = clamp(Math.floor(val), 0, 1000000000);
                                persistStats();
                                updateStatsUI();
                                updateGameUI();
                                console.log('%cTokens set to ' + state.tokens,'color:#22c55e;font-weight:bold');
                            }
                        });
                    } catch {}

            // --- UI helpers ---
            function setFeedback(msg, tone = 'info') {
                els.feedback.textContent = msg;
                const palette = {
                    info:  ['rgba(56, 189, 248, 0.08)', 'rgba(56, 189, 248, 0.18)', '#c7e9ff'],
                    good:  ['rgba(34, 197, 94, 0.10)', 'rgba(34, 197, 94, 0.26)', '#dcffd8'],
                    warn:  ['rgba(245, 158, 11, 0.10)', 'rgba(245, 158, 11, 0.30)', '#ffe6b8'],
                    bad:   ['rgba(239, 68, 68, 0.10)',  'rgba(239, 68, 68, 0.30)',  '#ffd1d1'],
                }[tone] || ['rgba(56, 189, 248, 0.08)', 'rgba(56, 189, 248, 0.18)', '#c7e9ff'];
                els.feedback.style.background = palette[0];
                els.feedback.style.borderColor = palette[1];
                els.feedback.style.color = palette[2];
            }

            function updateStatsUI() {
                els.tokens.textContent = state.tokens;
                els.streak.textContent = state.streak;
                els.bestStreak.textContent = state.bestStreak;
                els.wins.textContent = state.wins;
                els.games.textContent = state.games;
                els.muteSound.textContent = `Sound: ${state.soundOn ? 'On' : 'Off'}`;
                els.muteSound.setAttribute('aria-pressed', String(!state.soundOn));
                if (els.dailyToggle) els.dailyToggle.checked = !!state.daily;
                if (els.themeSelect) els.themeSelect.value = state.theme;
                if (els.fxToggle) els.fxToggle.checked = !!state.fxOn;
                if (els.reducedMotionToggle) els.reducedMotionToggle.checked = !!state.reducedMotion;
            }

            function updateGameUI() {
                els.rangeLabel.textContent = state.running ? `${state.min}–${state.max}` : '—';
                els.attemptsLeft.textContent = state.running ? state.triesLeft : '—';
                if (els.attemptsMini) els.attemptsMini.textContent = state.running ? state.triesLeft : '—';
                els.guessInput.disabled = !state.running;
                els.guessInput.setAttribute('aria-disabled', String(!state.running));
                els.guessBtn.disabled = !state.running;
                els.resetBtn.disabled = !state.running;
                const canParity = state.running && state.tokens >= 1;
                const canNarrow = state.running && state.tokens >= 2;
                const canLastDigit = state.running && state.tokens >= 1;
                const canDigitSum = state.running && state.tokens >= 2;
                els.hintParity.disabled = !canParity;
                els.hintNarrow.disabled = !canNarrow;
                if (els.hintLastDigit) els.hintLastDigit.disabled = !canLastDigit;
                if (els.hintDigitSum) els.hintDigitSum.disabled = !canDigitSum;
                els.hintParity.classList.toggle('hint-ready', canParity);
                els.hintNarrow.classList.toggle('hint-ready', canNarrow);
                if (els.hintLastDigit) els.hintLastDigit.classList.toggle('hint-ready', canLastDigit);
                if (els.hintDigitSum) els.hintDigitSum.classList.toggle('hint-ready', canDigitSum);

                // Attempts ring progress + color
                if (els.attemptsRing) {
                    const total = Math.max(1, state.totalTries || 0);
                    const left = clamp(state.triesLeft || 0, 0, total);
                    const pct = total ? left / total : 0;
                    const deg = Math.round(360 * pct) + 'deg';
                    let ringColor = '#22c55e';
                    if (pct <= 0.3) ringColor = '#ef4444';
                    else if (pct <= 0.6) ringColor = '#f59e0b';
                    els.attemptsRing.style.setProperty('--deg', deg);
                    els.attemptsRing.style.setProperty('--ringColor', ringColor);
                }

                // Auras on body per mode
                document.body.classList.toggle('mode-impossible', state.difficulty === 'impossible');
                document.body.classList.toggle('mode-extreme', state.difficulty === 'extreme');
            }

            function persistStats() {
                storage.set('ng_tokens', state.tokens);
                storage.set('ng_games', state.games);
                storage.set('ng_wins', state.wins);
                storage.set('ng_streak', state.streak);
                storage.set('ng_bestStreak', state.bestStreak);
                storage.set('ng_sound', state.soundOn);
                storage.set('ng_daily', state.daily);
                storage.set('ng_theme', state.theme);
                storage.set('ng_fx', state.fxOn);
                storage.set('ng_reduced', state.reducedMotion);
                storage.set('ng_achieve', state.achieve);
                storage.set('ng_results', state.results.slice(-30));
            }

            function seededRandom(seed) {
                // Mulberry32
                let t = seed >>> 0;
                return function() {
                    t += 0x6D2B79F5;
                    let r = Math.imul(t ^ t >>> 15, 1 | t);
                    r ^= r + Math.imul(r ^ r >>> 7, 61 | r);
                    return ((r ^ r >>> 14) >>> 0) / 4294967296;
                };
            }

            function pickSecret() {
                const cfg = DIFFICULTY[state.difficulty];
                state.min = cfg.min; state.max = cfg.max;
                if (state.daily) {
                    const daySeed = Math.floor(Date.now() / 86400000); // days since epoch
                    const rng = seededRandom(daySeed + (state.difficulty.charCodeAt(0) << 8));
                    state.secret = Math.floor(rng() * (cfg.max - cfg.min + 1)) + cfg.min;
                } else {
                    state.secret = Math.floor(Math.random() * (cfg.max - cfg.min + 1)) + cfg.min;
                }
                state.triesLeft = cfg.tries; state.totalTries = cfg.tries;
                state.guesses = [];
            }

            function hotCold(distance) {
                const span = state.max - state.min;
                const r = distance / Math.max(1, span);
                if (r <= 0.01) return 'Blazing!';
                if (r <= 0.03) return 'Sizzling!';
                if (r <= 0.07) return 'Very hot';
                if (r <= 0.12) return 'Hot';
                if (r <= 0.18) return 'Warm';
                if (r <= 0.28) return 'Cool';
                if (r <= 0.40) return 'Cold';
                return 'Freezing';
            }

            function startGame() {
                state.difficulty = els.difficulty.value;
                state.running = true;
                pickSecret();
                setFeedback('Game started. Make your first guess!', 'info');
                updateGameUI();
                els.guessInput.value = '';
                els.guessInput.min = String(state.min);
                els.guessInput.max = String(state.max);
                els.guessInput.placeholder = `Enter a number ${state.min}–${state.max}`;
                els.guessInput.focus();
                // reset heat bar at round start
                if (els.heatfill) els.heatfill.style.width = '0%';
                maybeUnlock('first_start', 'First Steps', 'Started your first round!');
                renderHistory();
                updateRangeBar();
            }
            function endGame(win) {
                state.running = false;
                state.games += 1;
                const sec = state.secret;
                if (win) {
                    const cfg = DIFFICULTY[state.difficulty];
                    const earned = clamp(state.triesLeft * cfg.bonus, 1, 9999);
                    state.tokens += earned;
                    state.wins += 1;
                    state.streak += 1;
                    state.bestStreak = Math.max(state.bestStreak, state.streak);
                    setFeedback(`Correct! The number was ${sec}. You earned ${earned} token${earned===1?'':'s'}.`, 'good');
                    sfx.play(sfx.coin);
                    confettiBurst();
                    maybeUnlock('first_win', 'Victory!', 'Won your first round.');
                    if (state.difficulty === 'impossible') maybeUnlock('win_impossible', 'Against All Odds', 'Won on Impossible.');
                    if (state.difficulty === 'extreme') maybeUnlock('win_extreme', 'Galactic Brain', 'Won on Extremely Impossible.');
                } else {
                    setFeedback(`Out of tries. The number was ${sec}. Better luck next time.`, 'bad');
                    state.streak = 0;
                }
                // Clear secret to avoid confusion after round end
                state.secret = 0;
                persistStats();
                updateStatsUI();
                updateGameUI();
                state.results.push(win ? 1 : 0);
                drawStatsChart();
                // reset heat bar after round ends
                if (els.heatfill) els.heatfill.style.width = '0%';
            }
            /* removed duplicate cheat and endGame */

            function makeGuess() {
                if (!state.running) return;
                const v = Number(els.guessInput.value);
                if (!Number.isFinite(v) || v < state.min || v > state.max) {
                    setFeedback(`Enter a valid number between ${state.min} and ${state.max}.`, 'warn');
                    return;
                }
                if (state.guesses.includes(v)) {
                    setFeedback('You already tried that number. Pick a different one.', 'warn');
                    return;
                }

                state.guesses.push(v);
                state.triesLeft = Math.max(0, state.triesLeft - 1);
                updateGameUI();

                if (v === state.secret) {
                    // show full heat before finishing
                    if (els.heatfill) els.heatfill.style.width = '100%';
                    endGame(true);
                    return;
                }

                const highLow = v > state.secret ? 'Too high' : 'Too low';
                const heat = hotCold(Math.abs(v - state.secret));
                const tail = state.triesLeft > 0 ? `${state.triesLeft} attempt${state.triesLeft===1?'':'s'} left.` : 'No attempts left.';
                setFeedback(`${highLow}. ${heat}. ${tail}`, state.triesLeft ? 'info' : 'bad');

                // update heat gauge width based on closeness
                if (els.heatfill) {
                    const span = Math.max(1, state.max - state.min);
                    const dist = Math.abs(v - state.secret);
                    const closeness = 1 - Math.min(1, dist / span);
                    const width = Math.round(closeness * 100);
                    els.heatfill.style.width = width + '%';
                }

                // shake feedback on miss
                els.feedback.classList.remove('shake');
                // force reflow to restart animation
                void els.feedback.offsetWidth;
                els.feedback.classList.add('shake');

                // history record
                renderHistory();
                updateRangeBar();

                if (state.triesLeft === 0) endGame(false);
            }

            // Achievements + Toasts
            function toast(msg) {
                if (!els.toastLayer) return;
                const d = document.createElement('div');
                d.className = 'toast';
                d.textContent = msg;
                els.toastLayer.appendChild(d);
                setTimeout(() => d.remove(), 3500);
            }
            function maybeUnlock(key, title, desc) {
                if (state.achieve[key]) return;
                state.achieve[key] = { t: Date.now(), title, desc };
                persistStats();
                renderAchievements();
                toast(`${title}: ${desc}`);
            }
            function renderAchievements() {
                if (!els.achievementsList) return;
                els.achievementsList.innerHTML = '';
                const keys = Object.keys(state.achieve);
                if (keys.length === 0) {
                    const li = document.createElement('li');
                    li.textContent = 'No achievements yet. Play to unlock!';
                    els.achievementsList.appendChild(li);
                    return;
                }
                for (const k of keys) {
                    const a = state.achieve[k];
                    const li = document.createElement('li');
                    li.className = 'stat';
                    li.innerHTML = `<div class="label">${new Date(a.t).toLocaleString()}</div><div class="value">${a.title} — ${a.desc}</div>`;
                    els.achievementsList.appendChild(li);
                }
            }

            function updateRangeBar() {
                if (!els.rangeFill || !state.running) { if (els.rangeFill) els.rangeFill.style.width = '0%'; return; }
                const span = DIFFICULTY[state.difficulty].max - DIFFICULTY[state.difficulty].min;
                const narrowed = state.max - state.min;
                const pct = 1 - (narrowed / Math.max(1, span));
                els.rangeFill.style.width = Math.round(pct * 100) + '%';
            }

            function drawStatsChart() {
                const c = els.statsChart; if (!c) return;
                const ctx = c.getContext('2d'); if (!ctx) return;
                const w = c.width, h = c.height;
                ctx.clearRect(0,0,w,h);
                const data = state.results.slice(-30);
                if (data.length === 0) return;
                ctx.strokeStyle = '#22c55e'; ctx.lineWidth = 2; ctx.beginPath();
                const step = w / Math.max(1, data.length - 1);
                for (let i = 0; i < data.length; i++) {
                    const x = i * step;
                    const y = h - data[i] * (h - 4) - 2;
                    i ? ctx.lineTo(x, y) : ctx.moveTo(x, y);
                }
                ctx.stroke();
            }

            // --- Hints ---
            function pay(cost) {
                if (state.tokens < cost) {
                    setFeedback(`Not enough tokens for that hint.`, 'warn');
                    return false;
                }
                state.tokens -= cost; persistStats(); updateStatsUI();
                return true;
            }

            function hintParity() {
                if (!state.running) return;
                if (!pay(1)) return;
                const parity = state.secret % 2 === 0 ? 'even' : 'odd';
                setFeedback(`Hint: The number is ${parity}.`, 'info');
                pulseSuccess(els.hintParity);
            }

            function hintNarrow() {
                if (!state.running) return;
                if (!pay(2)) return;
                // Compute a narrower window around the secret: shrink current range by ~60%
                const span = state.max - state.min;
                const windowSize = Math.max(5, Math.floor(span * 0.4));
                const half = Math.floor(windowSize / 2);
                const newMin = clamp(state.secret - half, DIFFICULTY[state.difficulty].min, state.secret);
                const newMax = clamp(state.secret + half, state.secret, DIFFICULTY[state.difficulty].max);
                state.min = newMin; state.max = newMax;
                els.rangeLabel.textContent = `${state.min}–${state.max}`;
                els.guessInput.min = String(state.min);
                els.guessInput.max = String(state.max);
                setFeedback(`Hint: The number is between ${state.min} and ${state.max}.`, 'info');
                pulseSuccess(els.hintNarrow);
            }

            function hintLastDigit() {
                if (!state.running) return;
                if (!pay(1)) return;
                const ld = Math.abs(state.secret) % 10;
                setFeedback(`Hint: The last digit is ${ld}.`, 'info');
                pulseSuccess(els.hintLastDigit);
            }

            function hintDigitSum() {
                if (!state.running) return;
                if (!pay(2)) return;
                const sum = String(Math.abs(state.secret)).split('').reduce((a,b)=>a+Number(b),0);
                setFeedback(`Hint: The sum of digits is ${sum}.`, 'info');
                pulseSuccess(els.hintDigitSum);
            }

            function renderHistory() {
                const box = document.getElementById('historyList');
                if (!box) return;
                if (!state.running && state.guesses.length === 0) { box.textContent = ''; return; }
                box.innerHTML = state.guesses.slice().reverse().map((g, idx)=>{
                    const mark = g === state.secret ? '✅' : (g > state.secret ? '⬆️' : '⬇️');
                    return `<span style="opacity:${1 - idx*0.08}">${g} ${mark}</span>`;
                }).join(' · ');
            }

            // --- Modal ---
            function openModal() { els.rulesModal.style.display = 'flex'; els.rulesModal.setAttribute('aria-hidden', 'false'); }
            function closeModal() { els.rulesModal.style.display = 'none'; els.rulesModal.setAttribute('aria-hidden', 'true'); }

                    // --- FX ---
                    function confettiBurst(count = 80) {
                        const layer = document.getElementById('fxLayer');
                        if (!layer) return;
                        const colors = ['#22c55e', '#38bdf8', '#f59e0b', '#ef4444', '#a78bfa'];
                        const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
                        for (let i = 0; i < count; i++) {
                            const d = document.createElement('div');
                            d.className = 'confetti';
                            const left = Math.random() * vw;
                            d.style.left = left + 'px';
                            d.style.setProperty('--x', (Math.random() * 40 - 20) + 'px');
                            d.style.background = colors[Math.floor(Math.random() * colors.length)];
                            d.style.transform = 'translate3d(0,-10px,0)';
                            d.style.animation = `confettiFall ${1.3 + Math.random() * 0.6}s ease-out forwards`;
                            d.style.borderRadius = Math.random() < 0.5 ? '2px' : '50%';
                            layer.appendChild(d);
                            setTimeout(() => d.remove(), 1800);
                        }
                    }

            // --- Events ---
            els.startBtn.addEventListener('click', startGame);
            els.resetBtn.addEventListener('click', () => { if (!state.running) return; startGame(); });
            els.guessBtn.addEventListener('click', makeGuess);
            els.guessInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') makeGuess(); });
            els.hintParity.addEventListener('click', hintParity);
            els.hintNarrow.addEventListener('click', hintNarrow);
            if (els.hintLastDigit) els.hintLastDigit.addEventListener('click', hintLastDigit);
            if (els.hintDigitSum) els.hintDigitSum.addEventListener('click', hintDigitSum);
            els.rulesBtn.addEventListener('click', openModal);
            els.closeRules.addEventListener('click', closeModal);
            els.rulesModal.addEventListener('click', (e) => { if (e.target === els.rulesModal) closeModal(); });
            els.resetStats.addEventListener('click', () => {
                if (!confirm('Reset all stats and tokens?')) return;
                state.tokens = 0; state.games = 0; state.wins = 0; state.streak = 0; state.bestStreak = 0;
                persistStats(); updateStatsUI(); setFeedback('Stats reset.', 'info');
            });
            els.muteSound.addEventListener('click', () => { state.soundOn = !state.soundOn; persistStats(); updateStatsUI(); });
            if (els.shareBtn) els.shareBtn.addEventListener('click', async () => {
                const text = `NGG — ${state.wins} wins / ${state.games} games, best streak ${state.bestStreak}. Current mode: ${state.difficulty}.`;
                try {
                    await navigator.clipboard.writeText(text);
                    toast('Copied share to clipboard!');
                } catch {
                    toast(text);
                }
            });

            // Settings & Achievements
            const openSettings = () => { els.settingsModal.style.display = 'flex'; els.settingsModal.setAttribute('aria-hidden','false'); };
            const closeSettingsFn = () => { els.settingsModal.style.display = 'none'; els.settingsModal.setAttribute('aria-hidden','true'); };
            const openAchievements = () => { els.achievementsModal.style.display = 'flex'; els.achievementsModal.setAttribute('aria-hidden','false'); renderAchievements(); };
            const closeAchievementsFn = () => { els.achievementsModal.style.display = 'none'; els.achievementsModal.setAttribute('aria-hidden','true'); };
            if (els.settingsBtn) els.settingsBtn.addEventListener('click', openSettings);
            if (els.closeSettings) els.closeSettings.addEventListener('click', closeSettingsFn);
            if (els.settingsModal) els.settingsModal.addEventListener('click', (e)=>{ if (e.target===els.settingsModal) closeSettingsFn(); });
            if (els.achievementsBtn) els.achievementsBtn.addEventListener('click', openAchievements);
            if (els.closeAchievements) els.closeAchievements.addEventListener('click', closeAchievementsFn);
            if (els.achievementsModal) els.achievementsModal.addEventListener('click', (e)=>{ if (e.target===els.achievementsModal) closeAchievementsFn(); });

            // Settings binds
            if (els.dailyToggle) els.dailyToggle.addEventListener('change', (e)=>{ state.daily = e.target.checked; persistStats(); });
            if (els.themeSelect) els.themeSelect.addEventListener('change', (e)=>{ state.theme = e.target.value; applyTheme(); persistStats(); });
            if (els.fxToggle) els.fxToggle.addEventListener('change', (e)=>{ state.fxOn = e.target.checked; applyFxToggle(); persistStats(); });
            if (els.reducedMotionToggle) els.reducedMotionToggle.addEventListener('change', (e)=>{ state.reducedMotion = e.target.checked; applyReducedMotion(); persistStats(); });

            // Button ripple effect (event delegation)
            document.addEventListener('click', (e) => {
                const t = e.target;
                if (!(t instanceof Element)) return;
                const btn = t.closest('.btn');
                if (!btn) return;
                if (btn.hasAttribute('disabled')) return;
                const rect = btn.getBoundingClientRect();
                const ink = document.createElement('span');
                ink.className = 'ripple-ink';
                const size = Math.max(rect.width, rect.height);
                ink.style.width = ink.style.height = size + 'px';
                const x = e.clientX - rect.left - size / 2;
                const y = e.clientY - rect.top - size / 2;
                ink.style.left = x + 'px';
                ink.style.top = y + 'px';
                btn.appendChild(ink);
                setTimeout(() => ink.remove(), 650);
            });

            // --- Init ---
            updateStatsUI();
            updateGameUI();
            setFeedback('Pick a difficulty and press Start to play.', 'info');

            // Apply settings on load
            applyTheme();
            applyFxToggle();
            applyReducedMotion();
            renderAchievements();

            function applyTheme() {
                const root = document.documentElement;
                switch (state.theme) {
                    case 'neon':
                        root.style.setProperty('--primary', '#22d3ee');
                        root.style.setProperty('--primary-600', '#06b6d4');
                        root.style.setProperty('--accent', '#a78bfa');
                        break;
                    case 'solar':
                        root.style.setProperty('--primary', '#f59e0b');
                        root.style.setProperty('--primary-600', '#d97706');
                        root.style.setProperty('--accent', '#f97316');
                        break;
                    default:
                        root.style.setProperty('--primary', '#22c55e');
                        root.style.setProperty('--primary-600', '#16a34a');
                        root.style.setProperty('--accent', '#38bdf8');
                }
            }
            function applyFxToggle() {
                const on = !!state.fxOn;
                if (els.bgCanvas) els.bgCanvas.style.display = on ? 'block' : 'none';
                const aur = document.querySelector('.aurora');
                if (aur) aur.style.display = on ? 'block' : 'none';
            }
            function applyReducedMotion() {
                document.body.style.setProperty('--reduced', state.reducedMotion ? '1' : '0');
                // Optionally reduce star speed or pause meteors if needed in future
            }

            // Helper: success pulse
            function pulseSuccess(el) {
                if (!el) return;
                el.classList.remove('pulse-success');
                void el.offsetWidth; // reflow
                el.classList.add('pulse-success');
                setTimeout(() => el.classList.remove('pulse-success'), 620);
            }

            // Background starfield with twinkles, meteors and parallax
            (function startStarfield() {
                const canvas = els.bgCanvas;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                if (!ctx) return;

                // DPR scaling for crispness
                const DPR = Math.min(2, window.devicePixelRatio || 1);
                let w = 0, h = 0;
                let stars = [], meteors = [], nebulas = [];
                let mouseX = 0, mouseY = 0; // for parallax

                function resize() {
                    const cw = window.innerWidth;
                    const ch = window.innerHeight;
                    w = canvas.width = Math.floor(cw * DPR);
                    h = canvas.height = Math.floor(ch * DPR);
                    canvas.style.width = cw + 'px';
                    canvas.style.height = ch + 'px';
                    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

                    // Density scales with area
                    const starCount = Math.floor((cw * ch) / 8500);
                    const nebCount = Math.max(2, Math.floor((cw * ch) / 400000));
                    stars = new Array(starCount).fill(0).map(() => ({
                        x: Math.random() * cw,
                        y: Math.random() * ch,
                        z: Math.random() * 0.9 + 0.1, // depth
                        t: Math.random() * Math.PI * 2, // twinkle phase
                        s: Math.random() * 0.9 + 0.1, // size factor
                    }));
                    nebulas = new Array(nebCount).fill(0).map(() => ({
                        x: Math.random() * cw,
                        y: Math.random() * ch,
                        r: Math.random() * 300 + 220,
                        hue: Math.random() < 0.5 ? 200 + Math.random() * 40 : 120 + Math.random() * 30, // blue/green
                        alpha: 0.08 + Math.random() * 0.08,
                        drift: (Math.random() * 0.6 + 0.2) * (Math.random() < 0.5 ? -1 : 1),
                    }));
                    meteors.length = 0; // clear
                }
                resize();
                window.addEventListener('resize', resize);

                // Mouse parallax
                window.addEventListener('mousemove', (e) => {
                    const cx = window.innerWidth / 2;
                    const cy = window.innerHeight / 2;
                    mouseX = (e.clientX - cx) / cx; // -1..1
                    mouseY = (e.clientY - cy) / cy; // -1..1
                });

                function maybeSpawnMeteor() {
                    if (meteors.length > 2) return;
                    if (Math.random() < 0.012) {
                        const fromTop = Math.random() < 0.5;
                        const startX = Math.random() * window.innerWidth * 0.3 + (fromTop ? 0 : window.innerWidth * 0.7);
                        const startY = fromTop ? -20 : Math.random() * window.innerHeight * 0.3;
                        const speed = 6 + Math.random() * 4;
                        meteors.push({ x: startX, y: startY, vx: speed, vy: speed * 0.35, life: 0, maxLife: 90 + Math.random() * 40 });
                    }
                }

                function drawNebulas() {
                    for (const n of nebulas) {
                        n.x += n.drift * 0.05;
                        if (n.x < -n.r) n.x = window.innerWidth + n.r;
                        if (n.x > window.innerWidth + n.r) n.x = -n.r;
                        const px = n.x + mouseX * 10;
                        const py = n.y + mouseY * 6;
                        const grad = ctx.createRadialGradient(px, py, 0, px, py, n.r);
                        grad.addColorStop(0, `hsla(${n.hue}, 70%, 55%, ${n.alpha})`);
                        grad.addColorStop(1, 'rgba(0,0,0,0)');
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.arc(px, py, n.r, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                function drawGalaxy() {
                    // Center galaxy roughly behind main app
                    const cx = window.innerWidth * 0.52 + mouseX * 12;
                    const cy = window.innerHeight * 0.45 + mouseY * 8;
                    const coreR = Math.min(window.innerWidth, window.innerHeight) * 0.10;
                    // Core glow
                    const core = ctx.createRadialGradient(cx, cy, 0, cx, cy, coreR * 2.2);
                    core.addColorStop(0, 'rgba(255,255,255,0.18)');
                    core.addColorStop(1, 'rgba(255,255,255,0)');
                    ctx.fillStyle = core; ctx.beginPath(); ctx.arc(cx, cy, coreR * 2.2, 0, Math.PI*2); ctx.fill();

                    // Spiral arms
                    const arms = 4;
                    const armLen = Math.min(window.innerWidth, window.innerHeight) * 0.55;
                    ctx.globalCompositeOperation = 'lighter';
                    for (let a = 0; a < arms; a++) {
                        const baseAngle = (a / arms) * Math.PI * 2;
                        for (let i = 0; i < 800; i++) {
                            const t = i / 800; // 0..1 along the arm
                            const angle = baseAngle + t * 5.2 + Math.sin(t * 6) * 0.05; // spiral twist
                            const r = t * armLen + (Math.random() - 0.5) * 8;
                            const x = cx + Math.cos(angle) * r + (Math.random() - 0.5) * 3;
                            const y = cy + Math.sin(angle) * r + (Math.random() - 0.5) * 3;
                            const alpha = (1 - t) * 0.24 + Math.random() * 0.06;
                            const size = 0.8 + Math.random() * 1.6;
                            ctx.fillStyle = `rgba(200,220,255,${alpha.toFixed(3)})`;
                            ctx.fillRect(x, y, size, size);
                        }
                    }
                    ctx.globalCompositeOperation = 'source-over';
                }

                function drawStars(t) {
                    for (const s of stars) {
                        // gentle drift + wrap
                        s.x += 0.02 * s.z;
                        if (s.x > window.innerWidth) s.x = 0;
                        s.t += 0.03 + 0.02 * s.z;
                        const tw = 0.6 + 0.4 * Math.sin(s.t);
                        const alpha = (0.25 + 0.55 * s.z) * tw;
                        const size = (0.6 + 1.2 * s.s * s.z);
                        const px = s.x + mouseX * (6 * s.z);
                        const py = s.y + mouseY * (4 * s.z);

                        ctx.fillStyle = `rgba(255,255,255,${alpha.toFixed(3)})`;
                        ctx.fillRect(px, py, size, size);
                    }
                }

                function drawMeteors() {
                    for (let i = meteors.length - 1; i >= 0; i--) {
                        const m = meteors[i];
                        m.x += m.vx;
                        m.y += m.vy;
                        m.life++;
                        const tail = 90;
                        const grad = ctx.createLinearGradient(m.x, m.y, m.x - tail, m.y - tail * 0.35);
                        grad.addColorStop(0, 'rgba(255,255,255,0.9)');
                        grad.addColorStop(1, 'rgba(255,255,255,0)');
                        ctx.strokeStyle = grad;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(m.x, m.y);
                        ctx.lineTo(m.x - tail, m.y - tail * 0.35);
                        ctx.stroke();
                        if (m.life > m.maxLife || m.x > window.innerWidth + 50 || m.y > window.innerHeight + 50) {
                            meteors.splice(i, 1);
                        }
                    }
                }

                let lastTime = 0;
                function tick(ts) {
                    const dt = ts - lastTime; lastTime = ts;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    drawNebulas();
                    drawGalaxy();
                    drawStars(ts);
                    maybeSpawnMeteor();
                    drawMeteors();
                    requestAnimationFrame(tick);
                }
                requestAnimationFrame(tick);
            })();
        })();
    </script>
</body>
</html>
