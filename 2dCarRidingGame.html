<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>2D Car Riding game</title>
  <style>
    /* ===== Base Layout ===== */
    html, body { margin: 0; height: 100%; overflow: hidden; background: #0e0f14; }
  #game { display:block; touch-action:none; user-select:none; -webkit-user-select:none; }
    #ui { position: fixed; inset: 0; pointer-events: none; color: #fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  #overlay { z-index: 2; pointer-events: auto; }
  #shop { z-index: 1; }
    .hud { position: absolute; left: 16px; top: 12px; background: rgba(0,0,0,.35); padding: 8px 12px; border-radius: 10px; backdrop-filter: blur(2px); font-weight: 600; }
    .hud span { min-width: 36px; display: inline-block; text-align: right; }
    .center { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); text-align: center; }
    .btn { pointer-events: auto; padding: 10px 16px; border-radius: 12px; border: none; background: #4ade80; color: #04210f; font-weight: 800; cursor: pointer; box-shadow: 0 6px 18px rgba(0,0,0,.35); }
    .tip { opacity: .85; margin-top: 6px; }
    #shop { position: absolute; right: 12px; top: 12px; background: rgba(0,0,0,.45); padding: 10px; border-radius: 12px; pointer-events: auto; display: grid; gap: 8px; min-width: 280px; }
    #shop h3 { margin: 0 0 6px 0; font-size: 14px; opacity: .9; }
    #shop button { padding: 8px 10px; border-radius: 10px; border: none; font-weight: 700; cursor: pointer; }
    #shop button:disabled { opacity: .45; cursor: not-allowed; }
    .error { color: #fecaca; }
    .shake { animation: shake 300ms ease; }
    @keyframes shake { 0%{transform:translateX(0)} 25%{transform:translateX(-4px)} 50%{transform:translateX(4px)} 75%{transform:translateX(-3px)} 100%{transform:translateX(0)} }

    /* ===== Overlay ===== */
    #overlay h1 { margin: 0 0 8px 0; }
    #overlay .subtitle { opacity:.85; margin-bottom: 10px; }
    #overlay .row { display:flex; gap:10px; justify-content:center; }

    /* ===== Minimap ===== */
    #minimap { position:absolute; right:12px; bottom:12px; background: rgba(0,0,0,.45); width: 220px; height: 120px; border-radius: 12px; pointer-events:none; overflow:hidden; }
    #minimap canvas { width:100%; height:100%; display:block; }

  /* ===== Notifications ===== */
  #toast { position:absolute; left: 50%; top: 12px; transform: translateX(-50%); background: rgba(0,0,0,.65); padding: 8px 12px; border-radius: 8px; pointer-events: none; opacity:0; transition: opacity .2s ease; }
  #toast.show { opacity: 1; }

    /* ===== Pause Hint ===== */
    #pauseHint { position:absolute; left:50%; bottom:16px; transform:translateX(-50%); background:rgba(0,0,0,.35); padding:6px 10px; border-radius:10px; pointer-events:none; opacity:.85; font-size:12px; }

  /* ===== Rotate Hint (mobile portrait) ===== */
  #rotateHint { position:absolute; left:50%; top:14px; transform:translateX(-50%); background: rgba(0,0,0,.65); padding:8px 12px; border-radius:10px; font-weight:700; pointer-events:none; display:none; z-index:3; }

    /* ===== Touch Controls (mobile only) ===== */
  #touchControls { display:none; position:absolute; inset:0; pointer-events:none; z-index: 0; }
    #touchControls .pad { position:absolute; bottom:16px; display:flex; gap:10px; pointer-events:auto; }
    #touchControls .left { left:16px; }
    #touchControls .right { right:16px; flex-direction:column; }
    #touchControls .tc-btn { width:68px; height:68px; border-radius:50%; border:none; background:rgba(17,24,39,.55); color:#fff; font-weight:900; font-size:22px; box-shadow:0 8px 24px rgba(0,0,0,.35); backdrop-filter: blur(4px); touch-action:none; user-select:none; -webkit-user-select:none; }
    #touchControls .tc-btn:active { transform: scale(0.96); }
    #touchControls .tc-small { position:absolute; top:14px; right:14px; width:44px; height:44px; border-radius:10px; border:none; background:rgba(17,24,39,.55); color:#fff; font-weight:800; font-size:18px; pointer-events:auto; touch-action:none; }
    @media (pointer: coarse), (max-width: 860px) {
      #touchControls { display:block; }
      #pauseHint { display:none; }
  .hud { left:8px; top:8px; padding:6px 8px; font-size:12px; }
  /* Hide the power-ups on mobile by default; we can expose later if desired */
  #shop { display:none !important; right:8px; top:8px; min-width:auto; width:min(70vw, 320px); grid-template-columns: 1fr; gap:6px; }
  #shop button { font-size:13px; padding:8px 10px; }
  #overlay .row .btn { font-size:16px; padding:12px 16px; }
  #minimap { right:8px; bottom:8px; width:180px; height:96px; }
  /* (DevTools UI removed) */
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <a class="homeBtn" href="index.html" aria-label="Home" style="position:fixed; left:10px; top:10px; z-index:80; display:inline-flex; align-items:center; gap:6px; padding:8px 10px; border-radius:10px; background: rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.16); color:#e5e7eb; text-decoration:none; font-weight:700; backdrop-filter: blur(6px);">üè† Home</a>

  <div id="ui">
    <div class="hud">Score: <span id="score">0</span> ‚Ä¢ Speed: <span id="spd">0</span> ‚Ä¢ Coins: <span id="coins">0</span> ‚Ä¢ Combo: <span id="combo">1.00x</span> ‚Ä¢ FPS: <span id="fps">0</span></div>

    <div id="shop">
      <h3>Power-Ups</h3>
      <button id="btnFly">Fly 5s ‚úàÔ∏è (8)</button>
      <button id="btnFewer">50% Fewer Objects 10s üßπ (8)</button>
  <button id="btnRush">Coin Rush 3s üí∞ (10)</button>
      <div class="tip">Earn 1 coin every 5s you survive, or grab on-road coins.</div>
      <div id="activePU" class="tip"></div>
      <div class="tip" id="cooldowns"></div>
    </div>

    <!-- minimap -->
    <div id="minimap"><canvas id="mini"></canvas></div>

    <!-- overlay -->
    <div id="overlay" class="center">
  <h1 id="title">2D Car Dodging Game</h1>
      <div class="subtitle">A/D to steer ‚Ä¢ Avoid traffic & obstacles ‚Ä¢ Use coins for power-ups</div>
      <div class="row"><button id="start" class="btn">Start Game</button></div>
      <div class="tip">ESC to pause ‚Ä¢ Fly ignores collisions ‚Ä¢ Fewer Objects reduces spawns ‚Ä¢ Coin Rush spawns coins only</div>
    </div>

    <div id="toast"></div>
    <div id="pauseHint">ESC to Pause/Resume</div>
  <div id="rotateHint">Rotate your device for a better view</div>

    <!-- Touch controls (shown on mobile) -->
    <div id="touchControls" aria-hidden="true">
      <div class="pad left">
        <button id="btnLeft"  class="tc-btn" aria-label="Steer Left">‚óÄ</button>
        <button id="btnRight" class="tc-btn" aria-label="Steer Right">‚ñ∂</button>
      </div>
      <div class="pad right">
        <button id="btnAccel" class="tc-btn" aria-label="Accelerate">‚è´</button>
        <button id="btnBrake" class="tc-btn" aria-label="Brake">‚è¨</button>
      </div>
      <button id="btnPause" class="tc-small" aria-label="Pause/Resume">‚è∏</button>
    </div>
  </div>

  <script>
  (() => {
    // =====================================================================
    //  Canvas Racer ‚Äî Single-file build for VS Code (no particles, no settings UI)
    // =====================================================================

    // --- Canvas & DPI ---
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const mini = document.getElementById('mini');
    const mctx = mini.getContext('2d');
    const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    // --- UI refs ---
    const ui = {
      score: document.getElementById('score'),
      spd: document.getElementById('spd'),
      coins: document.getElementById('coins'),
  fps: document.getElementById('fps'),
  combo: document.getElementById('combo'),
      overlay: document.getElementById('overlay'),
      start: document.getElementById('start'),
      title: document.getElementById('title'),
      btnFly: document.getElementById('btnFly'),
      btnFewer: document.getElementById('btnFewer'),
      btnRush: document.getElementById('btnRush'),
      activePU: document.getElementById('activePU'),
      cooldowns: document.getElementById('cooldowns'),
      shop: document.getElementById('shop'),
      toast: document.getElementById('toast'),
      btnReset: null, // not present in this trimmed UI
      btnPause: null  // not present in this trimmed UI
    };

    // --- Core settings (no UI to change them) ---
    const settings = {
      tilt: true,
      shake: true,
      volume: 0.8,
    dayNightCycle: true,
  showHit: false // hide hitboxes
    };

  // --- Developer Cheat flags ---
  const CHEAT = { active:false, noHitboxes:false, speedBoost:1 };

    // --- Economy / power-up costs ---
    const PU_COST_FLY   = 8;
    const PU_COST_FEWER = 8;
    const PU_COST_RUSH  = 10;

    // --- World globals (defined early) ---
    const horizonFrac = 0.33;
  let mountains = [], clouds = [], birds = [];
  let grassPattern = null;

    // --- Math helpers ---
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp  = (a,b,t)=>a+(b-a)*t;
    const rand  = (a,b)=>Math.random()*(b-a)+a;
    const choice= (arr)=>arr[Math.floor(Math.random()*arr.length)];
    // ensure min horizontal gap from existing entities near the top
    function pickLaneX(minGapNorm=0.18, minX=-0.9, maxX=0.9){
      // Try a few random picks within [minX,maxX] to find a spot with enough gap from topmost obstacles/traffic
      let best = clamp(0, minX, maxX), bestScore = -Infinity;
      for (let tries=0; tries<8; tries++){
        const cand = rand(minX, maxX);
        let ok = true; let score=0;
        for (const o of obstacles){ if (o.z < 0.5) { const dx=Math.abs(cand - o.x); if (dx < minGapNorm) ok=false; score += dx; } }
        for (const c of traffic){ if (c.z < 0.5) { const dx=Math.abs(cand - c.x); if (dx < minGapNorm) ok=false; score += dx; } }
        if (ok) return cand;
        if (score>bestScore){ bestScore=score; best=cand; }
      }
      return best; // fallback to the least-colliding candidate
    }

    function safeMaxNormForBase(base){
      // Compute the maximum normalized center offset so a sprite of given base width stays fully on-road
      const roadHalfW = road.botW * 0.5;
      const scale = (typeof getScale==='function'?getScale():0.55); // match project()
      const drawW = base * scale * 0.9; // from spriteDrawRect()
      const halfDraw = drawW * 0.5;
      const lineW = 6, buffer = 6;
      const maxCenter = Math.max(0, roadHalfW - halfDraw - lineW*0.5 - buffer);
      return clamp(maxCenter / Math.max(1, roadHalfW), 0.05, 0.98);
    }

    // --- Best score persistence ---
    let bestScore = 0; try { bestScore = parseInt(localStorage.getItem('cr_best')||'0', 10) || 0; } catch {}

    // --- Sprites ---
    const SPRITES_META = {
      cone:   { w:64, h:80,  hb:[0.18,0.45,0.64,0.48], src:'drive_assets/cone.png' },
      barrel: { w:70, h:80,  hb:[0.2,0.25,0.6,0.65],  src:`data:image/svg+xml;utf8,${encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' width='70' height='80'><rect x='8' y='10' width='54' height='62' rx='10' ry='10' fill='#9ca3af' stroke='#4b5563' stroke-width='3'/><rect x='8' y='36' width='54' height='8' fill='#6b7280'/></svg>`)}` },
      tree:   { w:120,h:140, hb:[0.36,0.45,0.28,0.5],  src:'drive_assets/tree.png' },
  rock:   { w:90, h:60,  hb:[0.12,0.35,0.76,0.5],  src:'drive_assets/rock.png' },
      // Traffic car sprites
      car_blue:  { w:120, h:220, hb:[0.18,0.18,0.64,0.68], src:'drive_assets/bluecar.png' },
      car_red:   { w:120, h:220, hb:[0.18,0.18,0.64,0.68], src:'drive_assets/redcar.png' },
  car_white: { w:120, h:220, hb:[0.18,0.18,0.64,0.68], src:'drive_assets/whitecar.png' },
      // Side decor image sprites
      bush:      { w:120, h:110, hb:[0.2,0.3,0.6,0.5],  src:'drive_assets/bush.png' },
      billboard: { w:260, h:160, hb:[0.1,0.2,0.8,0.6],  src:'drive_assets/billboard.png' },
  // Player car sprite
  usercar:   { w:120, h:220, hb:[0.18,0.18,0.64,0.68], src:'drive_assets/usercar.png' }
    };
    const IMAGES = {};
    let spritesReady = false;
  (function loadSprites(){
      let left=0;
      for (const k in SPRITES_META){
        const img = new Image();
        img.decoding = 'async';
        img.src = SPRITES_META[k].src;
        img.onload = ()=>{ if(--left<=0) spritesReady=true; };
        img.onerror = ()=>{ if(--left<=0) spritesReady=true; };
        IMAGES[k]=img; left++;
      }
      if(left===0) spritesReady=true;
    })();

    // --- Resize / DPI ---
    function buildGrassPattern(){
      try{
        const off = document.createElement('canvas');
        off.width = 96; off.height = 96;
        const g = off.getContext('2d');
        // base
        g.fillStyle = '#0e381d'; g.fillRect(0,0,off.width,off.height);
        // noise tiles
        for(let y=0;y<off.height;y+=6){
          for(let x=0;x<off.width;x+=6){
            const n = (Math.sin((x+y)*0.11) + Math.cos((x-y)*0.07))*0.25 + 0.5;
            const shade = 0.75 + n*0.25; // 0.75..1.0
            const r = Math.round(18*shade), gg=Math.round(100*shade), b=Math.round(48*shade);
            g.fillStyle = `rgb(${r},${gg},${b})`;
            g.fillRect(x,y,6,6);
          }
        }
        // a few blades
        for(let i=0;i<120;i++){
          const x=Math.random()*off.width, y=Math.random()*off.height;
          const len = 4 + Math.random()*8, tilt = (Math.random()-0.5)*0.6;
          g.strokeStyle = 'rgba(34,197,94,0.25)'; g.lineWidth=1;
          g.beginPath(); g.moveTo(x,y); g.lineTo(x+tilt*len, y-len); g.stroke();
        }
        grassPattern = g.createPattern(off,'repeat');
      }catch{ grassPattern=null; }
    }

    function resize(){
      const w = Math.floor(window.innerWidth);
      const h = Math.floor(window.innerHeight);
      canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
      canvas.width = Math.floor(w * DPR); canvas.height = Math.floor(h * DPR);
      ctx.setTransform(DPR,0,0,DPR,0,0);
      mini.width = 220; mini.height = 120;
  const roadW = Math.floor(Math.min(900, w * 0.7));
  road.topW = roadW; road.botW = roadW;
      buildMountains(); seedParallax();
      buildGrassPattern();
  updateTouchUI();
  updateRotateHint();
    }
    window.addEventListener('resize', resize);

  // --- Input ---
  const keys = {a:false,d:false,w:false,s:false}; let lastSteer = 0;
    window.addEventListener('keydown', e => {
      if (e.repeat) return;
      if (e.key==='a' || e.key==='A') { keys.a = true; triggerSwerve(-1); }
      if (e.key==='d' || e.key==='D') { keys.d = true; triggerSwerve(1); }
  if (e.key==='w' || e.key==='W') { keys.w = true; }
  if (e.key==='s' || e.key==='S') { keys.s = true; }
      if (e.key==='Escape') togglePause();
      if (state==='menu' && (e.key==='Enter' || e.key===' ')) start();
    });
    window.addEventListener('keyup', e => {
      if (e.key==='a' || e.key==='A') keys.a=false;
      if (e.key==='d' || e.key==='D') keys.d=false;
  if (e.key==='w' || e.key==='W') keys.w=false;
  if (e.key==='s' || e.key==='S') keys.s=false;
    });

    // --- Touch controls mapping ---
    function setupTouchControls(){
      const left  = document.getElementById('btnLeft');
      const right = document.getElementById('btnRight');
      const accel = document.getElementById('btnAccel');
      const brake = document.getElementById('btnBrake');
      const pause = document.getElementById('btnPause');
      if (!left || !right || !accel || !brake || !pause) return;

      // Prevent long-press menu and page scroll on touch only on canvas/controls
      const preventers = [document.getElementById('game'), left, right, accel, brake, pause];
      preventers.forEach(el=>{
        if(!el) return;
        el.addEventListener('contextmenu', e=> e.preventDefault());
        ['touchstart','touchmove','touchend','gesturestart'].forEach(ev=>{
          el.addEventListener(ev, e=> e.preventDefault(), { passive:false });
        });
      });

      function bindHold(el, down, up){
        let active = false;
        const end = () => { if (!active) return; active=false; up(); };
        el.addEventListener('pointerdown', e=>{ e.preventDefault(); active=true; try{ el.setPointerCapture(e.pointerId); }catch{} down(); });
        el.addEventListener('pointerup',   e=>{ e.preventDefault(); end(); });
        el.addEventListener('pointercancel', end);
        el.addEventListener('pointerleave',  end);
        // Also support regular mouse/touch events as fallback
        el.addEventListener('mousedown', e=>{ e.preventDefault(); active=true; down(); });
        window.addEventListener('mouseup', ()=> end());
        el.addEventListener('touchstart', e=>{ e.preventDefault(); active=true; down(); }, {passive:false});
        window.addEventListener('touchend', ()=> end(), {passive:false});
      }

      bindHold(left,  ()=>{ keys.a=true; triggerSwerve(-1); }, ()=>{ keys.a=false; });
      bindHold(right, ()=>{ keys.d=true; triggerSwerve( 1); }, ()=>{ keys.d=false; });
      bindHold(accel, ()=>{ keys.w=true; }, ()=>{ keys.w=false; });
      bindHold(brake, ()=>{ keys.s=true; }, ()=>{ keys.s=false; });
      pause.addEventListener('click', ()=> togglePause());
    }

    // Toggle visibility of shop/minimap based on state
    function updateUIState(){
      const shopEl = document.getElementById('shop');
      const miniWrap = document.getElementById('minimap');
      if (shopEl) shopEl.style.display = (state==='play') ? 'grid' : 'none';
      if (miniWrap) miniWrap.style.display = (state==='play') ? 'block' : 'none';
    }

    // --- Audio (swerve + crash only, no looping beeps) ---
    let audioCtx = null;
    function getAudio(){ if(!audioCtx){ const Ctx = window.AudioContext || window.webkitAudioContext; audioCtx=new Ctx(); } return audioCtx; }

    let swerveGate = 0;
    function triggerSwerve(dir){
      const steer = (keys.d?1:0)-(keys.a?1:0);
      const now = performance.now()/1000;
      if (now<swerveGate) return;
      swerveGate = now + (dir===Math.sign(lastSteer)?0.35:0.2);
      lastSteer=steer;
      playSwerve(dir);
    }
    function playSwerve(dir){
      try{
        const ac=getAudio(), dur=0.14;
        const nb=ac.createBuffer(1,ac.sampleRate*dur,ac.sampleRate);
        const d=nb.getChannelData(0);
        for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*(1-i/d.length);
        const src=ac.createBufferSource(); src.buffer=nb;
        const bp=ac.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1700; bp.Q.value=8;
        const g=ac.createGain(); g.gain.value=0;
        let pan=null;
        if(ac.createStereoPanner){ pan=ac.createStereoPanner(); pan.pan.value=dir>0?0.5:-0.5; src.connect(bp).connect(g).connect(pan).connect(ac.destination); }
        else { src.connect(bp).connect(g).connect(ac.destination); }
        const vol=clamp(settings.volume,0,1);
        src.start();
        bp.frequency.linearRampToValueAtTime(1100, ac.currentTime+dur*0.7);
        g.gain.linearRampToValueAtTime(0.12*vol, ac.currentTime+0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, ac.currentTime+dur);
        src.stop(ac.currentTime+dur+0.01);
      }catch(e){}
    }
    function crash(){
      try{
        const ac=getAudio(), dur=0.2;
        const n=ac.createBuffer(1,ac.sampleRate*dur,ac.sampleRate);
        const d=n.getChannelData(0);
        for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*(1-i/d.length);
        const src=ac.createBufferSource(); src.buffer=n;
        const g=ac.createGain(); g.gain.value=0.28*settings.volume;
        src.connect(g).connect(ac.destination); src.start(); src.stop(ac.currentTime+dur+0.01);
      }catch(e){}
    }
    // Custom coin sound (from drive_assets/coin.mp3) with synth fallback
    const COIN_SOUND_SRC = 'drive_assets/coin.mp3';
    let coinAudioTemplate = null;
    function loadCoinAudio(){
      try{
        const a = new Audio(COIN_SOUND_SRC);
        a.preload = 'auto';
        a.crossOrigin = 'anonymous';
        // Try to begin loading; browsers may defer until interaction but clone will still work after first gesture
        a.load?.();
        coinAudioTemplate = a;
      }catch{ coinAudioTemplate = null; }
    }
    function playCoin(){
      // Prefer your coin.mp3 if available; clone so overlapping picks don't cut off
      try{
        if (coinAudioTemplate){
          const a = coinAudioTemplate.cloneNode(true);
          a.volume = Math.max(0, Math.min(1, 0.7 * settings.volume));
          a.play().catch(()=>{ /* ignore; fallback below */ });
          return;
        }
      }catch{}
      // Fallback: synth ding via WebAudio
      try{
        const ac=getAudio(); const osc=ac.createOscillator(); const g=ac.createGain();
        osc.type='sine'; osc.frequency.setValueAtTime(880, ac.currentTime);
        osc.frequency.exponentialRampToValueAtTime(1320, ac.currentTime+0.06);
        g.gain.setValueAtTime(0, ac.currentTime);
        g.gain.linearRampToValueAtTime(0.18*settings.volume, ac.currentTime+0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, ac.currentTime+0.18);
        osc.connect(g).connect(ac.destination); osc.start(); osc.stop(ac.currentTime+0.2);
      }catch{}
    }
    function playCoin(){
      // short pleasant ding using a sine and quick envelope
      try{
        const ac=getAudio(); const osc=ac.createOscillator(); const g=ac.createGain();
        osc.type='sine'; osc.frequency.setValueAtTime(880, ac.currentTime);
        osc.frequency.exponentialRampToValueAtTime(1320, ac.currentTime+0.06);
        g.gain.setValueAtTime(0, ac.currentTime);
        g.gain.linearRampToValueAtTime(0.18*settings.volume, ac.currentTime+0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, ac.currentTime+0.18);
        osc.connect(g).connect(ac.destination); osc.start(); osc.stop(ac.currentTime+0.2);
      }catch(e){}
    }

    // --- Game state ---
    let state='menu';
    let score=0, coins=0, coinTimer=0;
    let baseSpeed=220, speedMul=1, elapsed=0;
    const road={ topW:120, botW:1600 };

  const player={ x:0, vx:0, accel:11, friction:11, tilt:0, maxTilt:0.12, flyTime:0, invuln:0, thrust:0 };

    const obstacles=[], decors=[], traffic=[], pickups=[];
  let spawnTimer=0, decorTimer=0, trafficTimer=0, pickupTimer=0;
    let spawnRateMul=1, fewerTimer=0, coinRushTimer=0;
    let shakeTime=0, shakeAmt=0, frames=0, fps=0, fpsAccum=0;
  // Effective speed multiplier for this frame (includes throttle)
  let speedMulNow = 1.0;
    // Near-miss combo system
    let combo = 1.0;       // score multiplier
    let comboTime = 0.0;   // time until decay starts

    // --- Parallax ---
    function seededRandom(seed){ let s=seed%2147483647; if(s<=0) s+=2147483646; return ()=> (s=s*16807%2147483647)/2147483647; }
    function buildMountains(){ const W=canvas.clientWidth,H=canvas.clientHeight,h=H*horizonFrac; const r=seededRandom(Math.floor(W*13+H*7)); mountains=[]; for(let i=0;i<6;i++){ const px=(i/5)*W, ph=60+r()*70, pw=180+r()*180; mountains.push({px,ph,pw}); } }
    function seedParallax(){ const W=canvas.clientWidth,H=canvas.clientHeight; const r=seededRandom(Math.floor(W*31+H*17)); clouds=[]; birds=[]; for(let i=0;i<8;i++) clouds.push({ x:r()*W, y:r()*H*0.25, s:r()*0.6+0.4, w:r()*140+120 }); for(let i=0;i<6;i++) birds.push({ x:r()*W, y:r()*H*0.22, s:r()*0.7+0.6 }); }

    // --- Shop / power-ups ---
    function refreshShop(){
      ui.coins.textContent = coins;
      ui.btnFly.disabled   = (state!=='play' || coins < PU_COST_FLY);
      ui.btnFewer.disabled = (state!=='play' || coins < PU_COST_FEWER);
      ui.btnRush.disabled  = (state!=='play' || coins < PU_COST_RUSH);
    }
    function toast(msg){ ui.toast.textContent=msg; ui.toast.classList.add('show'); setTimeout(()=>ui.toast.classList.remove('show'), 900); }
    function showShopError(msg){
      ui.activePU.textContent=msg; ui.activePU.classList.add('error');
      ui.shop.classList.remove('shake'); void ui.shop.offsetWidth; ui.shop.classList.add('shake');
      setTimeout(()=>{ if(ui.activePU.classList.contains('error')) ui.activePU.textContent=''; ui.activePU.classList.remove('error'); ui.shop.classList.remove('shake'); },800);
    }

    ui.btnFly.addEventListener('click', () => {
      if(state!=='play') return;
      if(coins>=PU_COST_FLY){ coins-=PU_COST_FLY; player.flyTime=Math.max(player.flyTime,5.0); toast('Fly 5s!'); refreshShop(); }
      else showShopError('Not enough coins');
    });
    ui.btnFewer.addEventListener('click', () => {
      if(state!=='play') return;
      if(coins>=PU_COST_FEWER){ coins-=PU_COST_FEWER; fewerTimer=Math.max(fewerTimer,10.0); spawnRateMul=0.5; toast('Fewer objects 10s'); refreshShop(); }
      else showShopError('Not enough coins');
    });
    ui.btnRush.addEventListener('click', () => {
      if (state!=='play') return;
      if (coins>=PU_COST_RUSH) {
        coins-=PU_COST_RUSH; coinRushTimer=Math.max(coinRushTimer,3.0);
        obstacles.length=0; traffic.length=0; spawnTimer=0; trafficTimer=9999; decorTimer=rand(0.35,0.7); pickupTimer=0;
        toast('Coin Rush! Coins only for 3s'); refreshShop();
      } else showShopError('Not enough coins');
    });

    // --- Start / pause ---
  function togglePause(){ if(state==='play'){ state='pause'; toast('Paused'); } else if(state==='pause'){ state='play'; toast('Resumed'); } updateTouchUI(); updateUIState(); }
    if (ui.start) {
      ui.start.addEventListener('click', () => { if(state!=='play') start(); });
      ui.start.addEventListener('keydown', (e)=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); if(state!=='play') start(); }});
    }

    // --- Responsive touch UI visibility ---
  function isMobileLike(){ return window.matchMedia('(pointer: coarse)').matches || window.innerWidth < 860; }
  function isPortrait(){ return window.innerHeight > window.innerWidth; }
    function updateTouchUI(){
      const el = document.getElementById('touchControls'); if (!el) return;
      const show = isMobileLike();
      el.style.display = show ? 'block' : 'none';
    }
    function updateRotateHint(){
      const rh = document.getElementById('rotateHint'); if (!rh) return;
      const show = isMobileLike() && isPortrait();
      rh.style.display = show ? 'block' : 'none';
    }

    // --- Projection ---
    function getScale(){
      // Slight zoom-out as you accelerate forward
      const t = Math.max(0, Math.min(1, (player.thrust||0) / 0.9));
      return 0.55 * (1 - 0.06 * t);
    }
    function project(x, z){
      const W=canvas.clientWidth,H=canvas.clientHeight;
      const roadW = road.botW;
      const sx=W/2 + x*(roadW*0.5);
      // Top-down: map z‚àà[0,2.2] to screen y‚àà[0,H]
      const sy = (z/2.2) * H;
      const scale = getScale();
      return {x:sx,y:sy,scale};
    }

    // --- Spawners ---
    function spawnObstacle(){
      // Cones less common; occasional rock
      const t = choice(['cone','cone','cone','cone','cone','cone','rock']);
      const cd=carDrawRect();
      const minGapNorm = Math.min(0.4, (cd.carWidth / road.botW) + 0.06);
      const base=SPRITES_META[t].w;
      const maxNormX = safeMaxNormForBase(base);
      const x=clamp(pickLaneX(minGapNorm, -maxNormX, maxNormX), -maxNormX, maxNormX);
      const z=-0.2; obstacles.push({type:t,x,z,base,rot:Math.random()*Math.PI});
    }
  function spawnDecor(){
    // Only spawn side decor that has images in drive_assets
  const type = choice(['tree','bush','bush','tree','billboard','bush','tree']);
    const side = Math.random()<0.5 ? -1 : 1;
    const x = side * rand(1.08, 1.34);
  const base = (type==='billboard'? rand(240, 320) : type==='tree' ? rand(150, 200) : rand(110, 140));
    const cand = {type,x,z:-0.2,base,seg:0,side};
    // Prevent overlap with recent decors near the top
    const cr = spriteDrawRect(cand.type, cand.x, cand.z, cand.base);
    for (let i=decors.length-1; i>=0; i--){
      const d = decors[i]; if (d.z >= 0.6) break;
      const dr = spriteDrawRect(d.type, d.x, d.z, d.base);
      if (rectsOverlap(cr, dr)) return; // skip this spawn
    }
    decors.push(cand);
  }
    function spawnTraffic(){
      const cd=carDrawRect();
      const minGapNorm = Math.min(0.5, (cd.carWidth / road.botW) + 0.10);
      const type=choice(['car_blue','car_red','car_white']);
      const base=Math.round(SPRITES_META[type].w * 1.15);
      const maxNormX = safeMaxNormForBase(base);
      const laneX=pickLaneX(minGapNorm, -maxNormX, maxNormX);
      // Add slight forward relative speed (dz factor) and lane change plan
      traffic.push({type,x:laneX,z:-0.2,base,vx:rand(-0.02,0.02), dz: rand(0.9, 1.15), laneTarget: laneX + rand(-0.25,0.25), laneTimer: rand(1.0, 3.0)});
    }
  function spawnPickup(){ const base=80; const maxNormX=safeMaxNormForBase(base); const x=rand(-maxNormX,maxNormX); pickups.push({type:'coin',x,z:-0.2,base,spin:0}); }

    // --- Draw helpers ---
    function roundRect(x,y,w,h,r){
      ctx.beginPath(); ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r);
      ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h); ctx.lineTo(x+r,y+h);
      ctx.quadraticCurveTo(x,y+h,x,y+h-r); ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y);
    }
    function spriteDrawRect(type, xNorm, z, base){
      const p=project(xNorm,z); const meta=SPRITES_META[type];
      // If we have an actual image, prefer its natural aspect ratio
      let aspect = meta.h/meta.w;
      const im = IMAGES[type];
      if (im && im.naturalWidth && im.naturalHeight) aspect = im.naturalHeight / im.naturalWidth;
      const drawW=base*p.scale*0.9; const drawH=drawW*aspect; const x=p.x-drawW/2; const y=p.y-drawH;
      return {x,y,w:drawW,h:drawH, p};
    }
    function spriteHitRect(type, draw){
      const hb=SPRITES_META[type].hb;
      return { x: draw.x + hb[0]*draw.w, y: draw.y + hb[1]*draw.h, w: hb[2]*draw.w, h: hb[3]*draw.h };
    }

    function drawObstacle(o){
      const dr=spriteDrawRect(o.type,o.x,o.z,o.base);
      // shadow under obstacle
      ctx.fillStyle='rgba(0,0,0,0.25)';
      ctx.beginPath();
      ctx.ellipse(dr.x+dr.w/2, dr.y+dr.h*0.95, dr.w*0.55, dr.h*0.18, 0,0,Math.PI*2);
      ctx.fill();
      // sprite or vector fallback
      if (spritesReady && IMAGES[o.type] && IMAGES[o.type].complete) {
        ctx.drawImage(IMAGES[o.type], dr.x, dr.y, dr.w, dr.h);
      } else {
        ctx.save();
        ctx.translate(dr.x+dr.w/2, dr.y+dr.h/2);
        ctx.scale(dr.w/100, dr.h/100);
        if(o.type==='cone'){
          ctx.fillStyle='#f97316';
          ctx.beginPath(); ctx.moveTo(-40,40); ctx.lineTo(0,-40); ctx.lineTo(40,40); ctx.closePath(); ctx.fill();
        } else if(o.type==='barrel'){
          ctx.fillStyle='#9ca3af'; roundRect(-35,-30,70,60,10); ctx.fill();
        } else if(o.type==='tree'){
          ctx.fillStyle='#22c55e'; ctx.beginPath(); ctx.ellipse(0,-10,40,30,0,0,Math.PI*2); ctx.fill();
          ctx.fillStyle='#8b5a2b'; roundRect(-4,10,8,40,4); ctx.fill();
        } else {
          ctx.fillStyle='#64748b'; roundRect(-45,-20,90,40,12); ctx.fill();
        }
        ctx.restore();
      }
      if (settings.showHit){
        let r=spriteHitRect(o.type,dr);
        r = shrinkRect(r, 0.9, 0.85); // match obstacle collision shrink
        ctx.strokeStyle='#ff3333'; ctx.lineWidth=2; ctx.strokeRect(r.x,r.y,r.w,r.h);
      }
    }

    function drawTraffic(c){
      const dr=spriteDrawRect(c.type, c.x, c.z, c.base);
      // shadow
      ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.beginPath(); ctx.ellipse(dr.x+dr.w/2, dr.y+dr.h*0.95, dr.w*0.55, dr.h*0.18, 0,0,Math.PI*2); ctx.fill();
      // sprite
      if (spritesReady && IMAGES[c.type] && IMAGES[c.type].complete) { ctx.drawImage(IMAGES[c.type], dr.x, dr.y, dr.w, dr.h); }
      else {
        // fallback simple car shape
        ctx.save(); ctx.translate(dr.x+dr.w/2, dr.y+dr.h*0.55); ctx.scale(dr.w/100, dr.h/160);
        ctx.fillStyle='#10b981'; roundRect(-45,-40,90,120,12); ctx.fill();
        ctx.fillStyle='#0b1220'; roundRect(-32,-38,64,38,8); ctx.fill();
        ctx.restore();
      }
      if (settings.showHit){
        let r=spriteHitRect(c.type, dr);
        r = shrinkRect(r, 0.96, 0.94); // match traffic collision shrink
        ctx.strokeStyle='#ff3333'; ctx.lineWidth=2; ctx.strokeRect(r.x,r.y,r.w,r.h);
      }
    }

    function drawPickup(pu){
      const pr=project(pu.x,pu.z); const size=pu.base*pr.scale*0.6; const x=pr.x,y=pr.y-size*0.8;
      pu.spin+=0.1; ctx.save(); ctx.translate(x,y); ctx.rotate(pu.spin);
      ctx.fillStyle='#ffd54a'; roundRect(-size*0.25,-size*0.25,size*0.5,size*0.5,8); ctx.fill();
      ctx.fillStyle='rgba(255,255,255,0.45)'; ctx.fillRect(-2, -size*0.25, 4, size*0.5);
      ctx.restore();
      if (settings.showHit){
        let r={ x: pr.x - size/2, y: pr.y - size, w: size, h: size };
        r = shrinkRect(r, 0.9, 0.9); // match pickup collision
        ctx.strokeStyle='#ff3333'; ctx.lineWidth=2; ctx.strokeRect(r.x,r.y,r.w,r.h);
      }
    }

    // --- Off-road decor ---
    function drawDecor(d){
      // Only image-backed side decor
      const dr = spriteDrawRect(d.type, d.x, d.z, d.base);
      const im = IMAGES[d.type];
      if (im && im.complete) {
        ctx.drawImage(im, dr.x, dr.y, dr.w, dr.h);
      } else {
        // Fallback simple shapes until image loads
        ctx.save(); ctx.translate(dr.x+dr.w/2, dr.y+dr.h/2); ctx.scale(dr.w/100, dr.h/100);
        const n = nightFactor();
        if (d.type==='billboard'){
          const face = n>0.5 ? '#0b1220' : '#0b1220';
          ctx.fillStyle=face; roundRect(-45,-20,90,40,6); ctx.fill();
          ctx.strokeStyle= n>0.5 ? '#7aa6ff' : '#93c5fd'; ctx.lineWidth=2; ctx.strokeRect(-45,-20,90,40);
        } else if (d.type==='tree'){
          ctx.fillStyle= n>0.5 ? '#1a6c3a' : '#22c55e'; ctx.beginPath(); ctx.ellipse(0,-10,40,30,0,0,Math.PI*2); ctx.fill();
          ctx.fillStyle='#8b5a2b'; roundRect(-4,10,8,40,4); ctx.fill();
          // simple highlight
          ctx.fillStyle = 'rgba(255,255,255,0.08)'; roundRect(-20,-26,40,12,6); ctx.fill();
        } else { // bush
          ctx.fillStyle= n>0.5 ? '#14532d' : '#166534'; ctx.beginPath(); ctx.ellipse(-16,10,22,20,0,0,Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.ellipse(10,12,26,22,0,0,Math.PI*2); ctx.fill();
          ctx.fillStyle= n>0.5 ? '#1f8f4a' : '#22c55e'; ctx.beginPath(); ctx.ellipse(0,0,18,16,0,0,Math.PI*2); ctx.fill();
        }
        ctx.restore();
      }
    }

    // --- Car ---
    function carDrawRect(){
      const W=canvas.clientWidth,H=canvas.clientHeight;
      const baseY=H-Math.min(200,H*0.28);
      const lift=player.flyTime>0?40+Math.sin(performance.now()/120)*6:0;
      const carY=baseY-lift;
  const carWidth=Math.min(130, Math.max(88, W*0.078));
      const carHeight=carWidth*1.8;
      const p=project(player.x,1.0);
      return {cx:p.x, cy:carY, carWidth, carHeight, tilt:(settings.tilt?player.tilt:0), lift};
    }
    function getCarHitboxMeta(){
      const cd = carDrawRect();
      const wMul = 0.50;
      const hMul = 0.80; // base shape before bottom-extension adjustments
      const vBias = 0.03; // align with current getCarRect settings after bottom extension
      const angle = cd.tilt * (cd.lift>0?0.7:1);
      const w = cd.carWidth * wMul;
      const h = cd.carHeight * hMul;
      const Lx = -cd.carWidth * (wMul*0.5);
      const Ly = -cd.carHeight * (hMul + vBias);
      return { cx: cd.cx, cy: cd.cy, angle, w, h, Lx, Ly };
    }
    function getCarRect(){
      // Build an oriented rect that follows car tilt, then return its axis-aligned bounds for collisions
      const meta = getCarHitboxMeta();
      const {cx, cy, angle, w, h, Lx, Ly} = meta;
      const c = Math.cos(angle), s = Math.sin(angle);
      function rot(px,py){ return { x: cx + px*c - py*s, y: cy + px*s + py*c }; }
      const tl = rot(Lx, Ly);
      const tr = rot(Lx + w, Ly);
      const br = rot(Lx + w, Ly + h);
      const bl = rot(Lx, Ly + h);
      const minX = Math.min(tl.x,tr.x,br.x,bl.x), maxX = Math.max(tl.x,tr.x,br.x,bl.x);
      const minY = Math.min(tl.y,tr.y,br.y,bl.y), maxY = Math.max(tl.y,tr.y,br.y,bl.y);
      return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
    }
    function drawCar(){
      const cd=carDrawRect(); const cx=cd.cx, cy=cd.cy, carWidth=cd.carWidth, carHeight=cd.carHeight, lift=cd.lift;
  // Headlight beams removed per request
      // body as sprite (keep tilt)
      ctx.save(); ctx.translate(cx, cy); ctx.rotate(cd.tilt*(lift>0?0.7:1));
      // Use spriteDrawRect logic manually to anchor at player position
      const pseudo = { w: carWidth*0.9, h: carHeight*0.9 };
      if (spritesReady && IMAGES['usercar'] && IMAGES['usercar'].complete) {
        // draw relative to translated origin so rotation centers correctly
        ctx.drawImage(IMAGES['usercar'], -pseudo.w/2, -pseudo.h, pseudo.w, pseudo.h);
      } else {
        // fallback to vector body if sprite not ready
        const grd=ctx.createLinearGradient(0,-carHeight/2,0,carHeight/2); grd.addColorStop(0,'#5eead4'); grd.addColorStop(1,'#0ea5e9');
        ctx.fillStyle=grd; roundRect(-carWidth/2,-carHeight/2,carWidth,carHeight,14); ctx.fill();
        ctx.fillStyle='#0b1220'; roundRect(-carWidth*0.35,-carHeight*0.35,carWidth*0.7,carHeight*0.32,10); ctx.fill();
        ctx.fillStyle='#0f1b33'; roundRect(-carWidth*0.45,-carHeight*0.05,carWidth*0.9,carHeight*0.18,10); ctx.fill();
      }
      ctx.restore();

  if (settings.showHit){
    // Draw rotated hitbox to follow tilt
    const meta = getCarHitboxMeta();
    ctx.save();
    ctx.translate(meta.cx, meta.cy);
    ctx.rotate(meta.angle);
    ctx.strokeStyle='#ff3333'; ctx.lineWidth=2;
    ctx.strokeRect(meta.Lx, meta.Ly, meta.w, meta.h);
    ctx.restore();
  }
    }

    // --- Background ---
    function nightFactor(){ if(!settings.dayNightCycle) return 0.25; const t=(performance.now()/1000)/40; return Math.sin(t*Math.PI*2)*0.5+0.5; }
    let centerDashOffset=0, grassOffset=0;
    function drawBackground(dt){
      const W=canvas.clientWidth,H=canvas.clientHeight;
      // Full top-down grass background (no sky)
      if (!grassPattern) buildGrassPattern();
      const screenDY = (baseSpeed*speedMulNow) * (H/2.2) / 900;
      if (state === 'play') grassOffset -= dt * screenDY;
      const tile = 96; const shiftY = - (grassOffset % tile);
      if (grassPattern){
        ctx.save(); ctx.translate(0, shiftY);
        ctx.fillStyle = grassPattern; ctx.fillRect(0, -tile, W, H + tile*2);
        ctx.restore();
      } else {
        ctx.fillStyle='#0f3b1d'; ctx.fillRect(0,0,W,H);
      }

      // Road as a centered rectangle
      const roadLeft = W/2 - road.botW/2;
      ctx.fillStyle='#1f1f1f'; ctx.fillRect(roadLeft,0,road.botW,H);
  // Shoulders
  ctx.fillStyle='#2a2a2a';
  ctx.fillRect(roadLeft-10,0,10,H);
  ctx.fillRect(roadLeft+road.botW,0,10,H);
      // Road edges
      ctx.strokeStyle='#cfcfcf'; ctx.lineWidth=6; ctx.setLineDash([]);
      ctx.beginPath(); ctx.moveTo(roadLeft,0); ctx.lineTo(roadLeft,H); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(roadLeft+road.botW,0); ctx.lineTo(roadLeft+road.botW,H); ctx.stroke();
  // Center vertical dashed line scrolling; match obstacle screen-speed and freeze when not playing
  const dashDY = (baseSpeed*speedMulNow) * (H/2.2) / 900; // same factor as obstacles (900)
  if (state === 'play') centerDashOffset -= dt * dashDY; // invert to move downward
      const spacing=50, dashLen=26, x=W/2;
      ctx.strokeStyle='#ffd966'; ctx.lineWidth=4;
      for(let y = - (centerDashOffset % spacing); y < H; y += spacing){
        ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y+dashLen); ctx.stroke();
      }
      // Cat's eyes along the center
      ctx.fillStyle = 'rgba(255,255,200,0.45)';
      for(let y = - (centerDashOffset % (spacing)); y < H; y += spacing){
        ctx.fillRect(x-1, y+dashLen+4, 2, 2);
      }
      // Edge posts along shoulders
      const postSpacing = 100, postH = 14, postW = 3;
      const yStart = - (centerDashOffset % postSpacing);
      ctx.fillStyle = '#e5e7eb';
      for(let y = yStart; y < H; y += postSpacing){
        ctx.fillRect(roadLeft-14, y, postW, postH);
        ctx.fillRect(roadLeft+road.botW+11, y, postW, postH);
      }
      // Rumble strip dashes just inside road edges
      ctx.fillStyle = '#3a3a3a';
      const rbx1 = roadLeft + 8, rbx2 = roadLeft + road.botW - 12;
      for(let y = - (centerDashOffset % 22); y < H; y += 22){
        ctx.fillRect(rbx1, y, 12, 3);
        ctx.fillRect(rbx2, y, 12, 3);
      }
    }

    // --- Collision ---
    function rectsOverlap(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
  function shrinkRect(r, fx=0.9, fy=0.85){ const nx=r.x + r.w*(1-fx)/2, ny=r.y + r.h*(1-fy)/2; return { x:nx, y:ny, w:r.w*fx, h:r.h*fy }; }

    // --- Game flow ---
    function start(){
      score=0; coins=0; coinTimer=0; speedMul=1; baseSpeed=220; elapsed=0;
      player.x=0; player.vx=0; player.tilt=0; player.flyTime=0; player.invuln=1.0;
      obstacles.length=0; decors.length=0; traffic.length=0; pickups.length=0;
      spawnTimer=0; decorTimer=0; trafficTimer=0; pickupTimer=0;
      fewerTimer=0; spawnRateMul=1; coinRushTimer=0;
      shakeTime=0; shakeAmt=0;
  state='play'; ui.overlay.style.display='none';
  ui.title.textContent = '2D Car Dodging Game';
      refreshShop(); toast('Good luck! Best: '+bestScore);
  updateTouchUI();
  updateUIState();
    }
    function gameOver(){
  state='over'; ui.overlay.style.display='block'; ui.title.textContent='Crashed!';
  updateUIState();
      if (Math.floor(score)>bestScore){
        bestScore=Math.floor(score);
        try{ localStorage.setItem('cr_best', String(bestScore)); }catch{}
        toast('New Best: '+bestScore);
      }
    }

    // --- Update ---
    let last=0;
    function update(dt){
      // FPS
      frames++; fpsAccum+=dt; if(fpsAccum>=0.5){ fps=Math.round(frames/fpsAccum); frames=0; fpsAccum=0; ui.fps.textContent=fps; }

      // Difficulty curves: chill ‚Üí chaos
      elapsed += dt;
  const slowPhase = clamp(1 - Math.min(elapsed, 60)/60, 0, 1);    // 1‚Üí0 over first minute
  const chaos     = clamp((elapsed - 60) / 240, 0, 1);            // 0 at 60s ‚Üí 1 at 5min
  const curve     = (1 - slowPhase)*0.5 + chaos*0.5; 
  // Faster overall game speed
  baseSpeed = lerp(300, 700, curve); 
  // Higher dynamic multiplier envelope
  speedMul  = lerp(1.2, 2.5, curve); 
  // Stronger forward acceleration
  const ACCEL_RATE = 1.9;  // per second
  const BRAKE_RATE = 1.6;  // per second
  const DRAG_RATE  = 1.0;  // per second toward 0
  const MAX_POS    = 1.15; // max positive thrust
  const MAX_NEG    = 0.45; // max negative thrust
  if (keys.w) player.thrust = Math.min(MAX_POS, player.thrust + ACCEL_RATE*dt);
  if (keys.s) player.thrust = Math.max(-MAX_NEG, player.thrust - BRAKE_RATE*dt);
  if (!keys.w && !keys.s){
    if (player.thrust>0) player.thrust = Math.max(0, player.thrust - DRAG_RATE*dt);
    else if (player.thrust<0) player.thrust = Math.min(0, player.thrust + DRAG_RATE*dt);
  }
  const BASE_THRUST = 0.5; // baseline forward boost even without accelerating
  speedMulNow = speedMul * Math.max(0.1, 1 + BASE_THRUST + player.thrust) * (CHEAT.speedBoost||1);

      // Controls
      const steer = (keys.d?1:0) - (keys.a?1:0);
      if (steer!==0) triggerSwerve(steer);
      // Apply steering acceleration
      player.vx += steer * player.accel * dt;
      // When no steer input, decelerate without overshooting and snap tiny values to 0 to avoid idle drift
      if (steer===0){
        const decel = player.friction * dt;
        if (Math.abs(player.vx) <= decel) player.vx = 0; else player.vx += -Math.sign(player.vx) * decel;
        if (Math.abs(player.vx) < 0.02) player.vx = 0; // deadzone
      }
  player.vx = clamp(player.vx, -3.0, 3.0);
      // Keep the car fully within the road edges using visible width (prevents peeking past lines)
      {
        const cd = carDrawRect();
        const roadHalfW = road.botW * 0.5;
        const carHalfVisible = cd.carWidth * 0.5;
        const lineW = 6, extra = 6; // account for edge line width and a small buffer
        const maxCenter = Math.max(0, roadHalfW - carHalfVisible - lineW*0.5 - extra);
        const maxNormX = clamp(maxCenter / Math.max(1, roadHalfW), 0.1, 0.98);
  if (player.vx !== 0) player.x = clamp(player.x + player.vx * dt * 0.68, -maxNormX, maxNormX);
      }
      const targetTilt=(player.vx/2.6)*player.maxTilt;
      player.tilt += (targetTilt - player.tilt) * (1 - Math.pow(0.001, dt));

      // Power-ups
      if (player.flyTime>0)  player.flyTime=Math.max(0, player.flyTime-dt);
      if (player.invuln>0)   player.invuln=Math.max(0, player.invuln-dt);
      if (fewerTimer>0){ fewerTimer=Math.max(0,fewerTimer-dt); if (fewerTimer===0) spawnRateMul=1; }
      if (coinRushTimer>0)   coinRushTimer=Math.max(0, coinRushTimer-dt);

      // Coins over time
      coinTimer += dt; if (coinTimer>=5){ coinTimer-=5; coins+=1; refreshShop(); toast('+1 coin'); }

      // Spawn timers
      spawnTimer-=dt; decorTimer-=dt; trafficTimer-=dt; pickupTimer-=dt;

      // Spawns
  const baseInterval = lerp(2.6, 0.9, curve);
  const minSpawn = (baseInterval / speedMulNow) / Math.max(0.0001, spawnRateMul);

      if (coinRushTimer>0){
        // Coin-only mode
        if (pickupTimer<=0){ spawnPickup(); if (Math.random()<0.55) spawnPickup(); pickupTimer=lerp(0.7, 0.45, chaos); }
        if (decorTimer<=0){ spawnDecor(); if (Math.random()<0.35) spawnDecor(); decorTimer=rand(1.2, 2.0); }
      } else {
        if (spawnTimer<=0){ spawnObstacle(); if (Math.random() < (0.12 + 0.18*chaos) * spawnRateMul) spawnObstacle(); spawnTimer=minSpawn; }
        if (decorTimer<=0){
          // Spawn more frequent side decor with slight clustering
          spawnDecor(); if (Math.random()<0.45) spawnDecor();
          decorTimer=rand(1.1, 2.2);
        }
  // Fewer cars on mobile (less space)
  const baseLimit = Math.round(lerp(3, 11, chaos));
  const trafficLimit = isMobileLike() ? Math.max(2, Math.floor(baseLimit * 0.6)) : baseLimit;
        if (trafficTimer<=0){
          if (traffic.length < trafficLimit) {
            spawnTraffic();
            // Often spawn a second car if there's room
            const secondProb = (isMobileLike() ? 0.5 : 1.0) * lerp(0.35, 0.6, chaos);
            if (traffic.length < trafficLimit && Math.random() < secondProb) spawnTraffic();
          }
          trafficTimer = (isMobileLike() ? 1.2 : 1.0) * lerp(2.5, 0.65, chaos);
        }
  if (pickupTimer<=0){ if (pickups.length < 3 + Math.floor(2*chaos)) spawnPickup(); pickupTimer=lerp(1.9, 1.2, chaos); }
      }

      const carR=getCarRect();

      // Helper: award near-miss once per object when close but not colliding
      function tryNearMiss(obj, r, carRect){
        if (!obj || obj.nm) return;
        const carTop = carRect.y, carBottom = carRect.y + carRect.h;
        const vertOverlap = (r.y < carBottom) && (r.y + r.h > carTop);
        if (!vertOverlap) return;
        const carCx = carRect.x + carRect.w/2;
        const objCx = r.x + r.w/2;
        const distX = Math.abs(objCx - carCx);
        const threshold = Math.max(18, carRect.w * 0.22);
        if (distX < threshold){
          obj.nm = true;
          combo = Math.min(5.0, combo + 0.25); comboTime = 1.6;
          // Reward: +1 coin with popup and sound
          coins += 1; refreshShop(); try{ playCoin(); }catch{}
          // transient toast for near-miss
          try{
            ui.toast.textContent = 'near miss! +1 coin';
            ui.toast.classList.add('show');
            setTimeout(()=> ui.toast.classList.remove('show'), 600);
          }catch{}
        }
      }

      // Obstacles
      for (let i=obstacles.length-1;i>=0;i--){
  const o=obstacles[i]; o.z += dt*(baseSpeed*speedMulNow)/900;
        // Remove only when fully off-screen bottom
        const drTest = spriteDrawRect(o.type, o.x, o.z, o.base);
        if (drTest.y > canvas.clientHeight) { obstacles.splice(i,1); continue; }
        // ensure stays on-road (e.g., after resize)
        { const maxNormX=safeMaxNormForBase(o.base); o.x = clamp(o.x, -maxNormX, maxNormX); }
        const dr=spriteDrawRect(o.type,o.x,o.z,o.base); let r=spriteHitRect(o.type,dr);
        r = shrinkRect(r, 0.9, 0.85); const carRS = shrinkRect(carR, 0.9, 0.9);
  if (!CHEAT.noHitboxes && player.flyTime<=0 && player.invuln<=0 && rectsOverlap(carRS,r)){
          crash(); if (settings.shake){ shakeTime=0.35; shakeAmt=14; }
          gameOver(); obstacles.length=0; decors.length=0; traffic.length=0; pickups.length=0; break;
  }
  else { tryNearMiss(o, r, carR); }
      }

    // Traffic
      for (let i=traffic.length-1;i>=0;i--){
        const c=traffic[i];
        // independent forward speed factor
  c.z += dt*(baseSpeed*speedMulNow)* (c.dz || 1) / 1000;
        // lane change towards a soft target
        c.laneTimer = (c.laneTimer || 0) - dt;
        if (c.laneTimer <= 0) {
          c.laneTarget = clamp((c.laneTarget || c.x) + rand(-0.5,0.5), -0.95, 0.95);
          c.laneTimer = rand(1.0, 3.0);
        }
        let steerX = clamp((c.laneTarget - c.x), -0.6, 0.6);
        // Dampen sudden swerves near player to reduce unfair merges
        let damp = 1.0, noiseAmp = 0.03;
        try {
          const cd = carDrawRect();
          const drN = spriteDrawRect(c.type, c.x, c.z, c.base);
          const cx = cd.cx, cy = cd.cy;
          const objCx = drN.x + drN.w/2, objCy = drN.y + drN.h*0.5;
          const nearY = Math.abs(objCy - cy) < 160;
          const nearX = Math.abs(objCx - cx) < cd.carWidth * 0.85;
          if (nearY && nearX){
            damp = 0.35; noiseAmp = 0.008;
            const toward = Math.sign(player.x - c.x);
            if (Math.sign(steerX) === toward) steerX *= 0.5;
          }
        } catch{}
        c.vx += steerX * 0.6 * dt * damp + rand(-noiseAmp,noiseAmp)*dt;
        c.vx = clamp(c.vx, -0.35, 0.35);
        c.x += c.vx * dt;
        const maxNormX = safeMaxNormForBase(c.base); c.x=clamp(c.x,-maxNormX,maxNormX);
        // Remove only when fully off-screen bottom
        { const drTest=spriteDrawRect(c.type,c.x,c.z,c.base); if (drTest.y > canvas.clientHeight) { traffic.splice(i,1); continue; } }
  if (!CHEAT.noHitboxes && player.flyTime<=0 && player.invuln<=0){
          const dr=spriteDrawRect(c.type,c.x,c.z,c.base); let r=spriteHitRect(c.type, dr); r = shrinkRect(r, 0.96, 0.94); const carRS = shrinkRect(carR, 0.9, 0.9);
          if (rectsOverlap(carRS,r)){
            crash(); if (settings.shake){ shakeTime=0.4; shakeAmt=16; }
            gameOver(); break;
          }
          else { tryNearMiss(c, r, carR); }
        }
      }

      // Pickups
      for (let i=pickups.length-1;i>=0;i--){
  const pu=pickups[i]; pu.z += dt*(baseSpeed*speedMulNow)/980;
        // Remove only when fully off-screen bottom
        { const prTest=project(pu.x, pu.z); const sizeTest=pu.base*prTest.scale*0.6; if (prTest.y - sizeTest > canvas.clientHeight) { pickups.splice(i,1); continue; } }
        { const maxNormX=safeMaxNormForBase(pu.base); pu.x = clamp(pu.x, -maxNormX, maxNormX); }
  const p=project(pu.x,pu.z); const size=pu.base*p.scale*0.6; let r={x:p.x-size/2,y:p.y-size,w:size,h:size}; r = shrinkRect(r,0.9,0.9);
        // While flying, slightly expand car rect for pickups so coins still collect
        const carForPickup = (player.flyTime>0) ? shrinkRect(carR, 1.05, 1.15) : carR;
        if (rectsOverlap(carForPickup,r)){
          coins+=1; refreshShop(); pickups.splice(i,1);
          try{ playCoin(); }catch{}
          toast('+1 coin');
        }
      }

      // Off-road decor update
      for (let i=decors.length-1;i>=0;i--){
        const d=decors[i];
        d.z += dt * (baseSpeed*speedMulNow) / 1000;
        if (d.type==='guard' || d.type==='fence') d.seg += dt;
        const prTest=project(d.x, d.z);
        if (prTest.y > canvas.clientHeight + 10){ decors.splice(i,1); continue; }
      }

    // Combo decay and HUD
    if (combo > 1){ if (comboTime > 0) comboTime = Math.max(0, comboTime - dt); else combo = Math.max(1, combo - 0.4*dt); }
    // HUD / scoring
    score += dt * 10 * speedMulNow * combo; ui.score.textContent=Math.floor(score);
  ui.spd.textContent=Math.floor(120 + 220*speedMulNow);
    if (ui.combo) ui.combo.textContent = combo.toFixed(2) + 'x';
      const list=[]; if(player.flyTime>0) list.push(`Flying ${player.flyTime.toFixed(1)}s`); if(fewerTimer>0) list.push(`Fewer objs ${fewerTimer.toFixed(1)}s`); if (coinRushTimer>0) list.push(`Coin Rush ${coinRushTimer.toFixed(1)}s`);
      ui.activePU.textContent=list.join(' ‚Ä¢ ');
      ui.cooldowns.textContent = `Invulnerability ${player.invuln.toFixed(1)}s`;
    }

    // --- Drawing composition ---
    function drawWorldLists(dt){
      decors.sort((a,b)=>a.z-b.z); for(const d of decors) drawDecor(d);
      obstacles.sort((a,b)=>a.z-b.z); for(const o of obstacles) drawObstacle(o);
      traffic.sort((a,b)=>a.z-b.z); for(const c of traffic) drawTraffic(c);
      pickups.sort((a,b)=>a.z-b.z); for(const p of pickups) drawPickup(p);
      drawCar();
    }
    function drawUIExtras(){
      mctx.clearRect(0,0,mini.width,mini.height);
      mctx.fillStyle='#111827'; mctx.fillRect(0,0,mini.width,mini.height);
      mctx.fillStyle='#94a3b8'; mctx.fillRect(mini.width/2-2,0,4,mini.height);
      const mapZ=z=>(1-z/2.2)*mini.height, mapX=x=> mini.width/2 + x*(mini.width*0.45);
      mctx.fillStyle='#f59e0b'; pickups.forEach(p=> mctx.fillRect(mapX(p.x)-2,mapZ(p.z)-2,4,4));
      mctx.fillStyle='#ef4444'; obstacles.forEach(o=> mctx.fillRect(mapX(o.x)-2,mapZ(o.z)-2,4,4));
      mctx.fillStyle='#10b981'; traffic.forEach(t=> mctx.fillRect(mapX(t.x)-2,mapZ(t.z)-2,4,4));
      mctx.fillStyle='#60a5fa'; mctx.fillRect(mapX(player.x)-3, mini.height-8, 6, 6);
    }

    function drawEverything(dt){
      // quick shake decay (fast on death)
      if (shakeTime>0){ const decay = (state==='play'?1.0:3.0); shakeTime=Math.max(0, shakeTime-dt*decay); }
      if (settings.shake && shakeTime>0){
        const a=(Math.random()*2-1)*shakeAmt*(shakeTime/0.45);
        const b=(Math.random()*2-1)*shakeAmt*(shakeTime/0.45);
        ctx.save(); ctx.translate(a,b); drawBackground(dt); drawWorldLists(dt); ctx.restore();
      } else {
        drawBackground(dt); drawWorldLists(dt);
      }
      // Day-night tint overlay (subtle)
      try {
        const W=canvas.clientWidth,H=canvas.clientHeight; const n=nightFactor();
        if (n>=0){
          if (n>0.5){ // night ‚Äì cool blue tint increasing up to ~0.25 alpha
            const a = (n-0.5)*0.35;
            ctx.fillStyle = `rgba(8, 20, 56, ${a.toFixed(3)})`;
            ctx.fillRect(0,0,W,H);
          } else { // day ‚Äì very subtle warm haze
            const a = (0.5-n)*0.08;
            if (a>0){ ctx.fillStyle = `rgba(255, 210, 130, ${a.toFixed(3)})`; ctx.fillRect(0,0,W,H); }
          }
        }
      } catch{}
      drawUIExtras();
    }

    // --- Frame loop ---
    function frame(t){
      const time=t/1000; const dt=Math.min(0.033, time - last || 0); last=time;
      if (state==='play') update(dt);
      drawEverything(dt);
  if (state==='menu' || state==='over') ui.overlay.style.display='block'; else ui.overlay.style.display='none';
  // keep touch UI in sync if viewport or state changes mid-frame
  updateTouchUI();
  updateRotateHint();
  updateUIState();
      requestAnimationFrame(frame);
    }

    // --- Start / Tests / Boot ---
    function startButtonTest(){ if (!ui.start) return; const prev=state; state='menu'; ui.start.dispatchEvent(new Event('click')); console.assert(state==='play','Start button should trigger start()'); state=prev; }
    function projectionSanityTest(){ const near=project(0,0.1), far=project(0,1.5); console.assert(far.y>near.y,'Projected y should grow with z'); }
    function shopButtonsTest(){
      const prevState=state, prevCoins=coins; state='play';
      coins=PU_COST_RUSH-1; refreshShop(); console.assert(ui.btnRush.disabled,'Rush disabled with < cost');
      coins=PU_COST_RUSH; refreshShop(); console.assert(!ui.btnRush.disabled,'Rush enabled with >= cost');
      coins=PU_COST_FLY-1; refreshShop(); console.assert(ui.btnFly.disabled,'Fly disabled with < cost');
      coins=PU_COST_FEWER; refreshShop(); console.assert(!ui.btnFewer.disabled,'Fewer enabled with >= cost');
      state=prevState; coins=prevCoins; refreshShop();
    }
    function coinRushTest(){
      const prev=coinRushTimer; coinRushTimer=1.0;
      const oCount=obstacles.length, tCount=traffic.length;
      spawnTimer=0; trafficTimer=0; pickupTimer=0;
      update(0.016);
      console.assert(obstacles.length===oCount && traffic.length===tCount,'No new obstacles/traffic during rush');
      coinRushTimer=prev;
    }

    function runTests(){
      try{
        console.assert(typeof horizonFrac==='number' && horizonFrac>0 && horizonFrac<1, 'horizonFrac 0..1');
        console.assert(Array.isArray(mountains), 'mountains array');
        setTimeout(()=>{ if(!(mountains && mountains.length>0)) console.error('TEST FAIL: mountains not built'); else console.log('TEST PASS: mountains built', mountains.length); }, 0);
        shopButtonsTest();
        projectionSanityTest();
        coinRushTest();
        startButtonTest();
        setTimeout(()=>{ console.log('Final Check #1 OK'); }, 1000);
        setTimeout(()=>{ console.log('Final Check #2 OK'); }, 2500);
      }catch(e){ console.error('TEST ERROR:', e); }
    }

    function togglePause(){ if (state==='play'){ state='pause'; toast('Paused'); } else if (state==='pause'){ state='play'; toast('Resumed'); } }

    function start(){
      score=0; coins=0; coinTimer=0; speedMul=1; baseSpeed=220; elapsed=0;
      player.x=0; player.vx=0; player.tilt=0; player.flyTime=0; player.invuln=1.0;
      obstacles.length=0; decors.length=0; traffic.length=0; pickups.length=0;
      spawnTimer=0; decorTimer=0; trafficTimer=0; pickupTimer=0;
      fewerTimer=0; spawnRateMul=1; coinRushTimer=0;
      shakeTime=0; shakeAmt=0;
      state='play'; ui.overlay.style.display='none';
  ui.title.textContent = '2D Car Dodging Game';
      refreshShop(); toast('Good luck! Best: '+bestScore);
    }

    // Bind ESC to pause in global handler above; wire start button already done.
  resize();
  setupTouchControls();
  loadCoinAudio();
    requestAnimationFrame(frame);
  updateUIState();
  setTimeout(runTests, 10);


  // --- Console cheat trigger ---
  try{
    Object.defineProperty(window, 'cheatcode', {
      configurable: true,
      get(){
  CHEAT.active = true; CHEAT.noHitboxes = true; CHEAT.speedBoost = 5000;
  try{ toast('CHEAT: no hitboxes + 500x speed'); }catch{}
  console.info('%cCHEAT ENABLED%c  no-hit + 500x speed','background:#22c55e;color:#04140a;padding:2px 6px;border-radius:6px','');
        return 'CHEAT ENABLED';
      }
    });
    // Optional: allow turning it off with resetcheat
    Object.defineProperty(window, 'resetcheat', {
      configurable: true,
      get(){ CHEAT.active=false; CHEAT.noHitboxes=false; CHEAT.speedBoost=1; try{ toast('CHEAT disabled'); }catch{}; console.info('CHEAT disabled'); return 'CHEAT disabled'; }
    });

    // Callable fallbacks for consoles that don't resolve bare identifiers to window props
    window.enableCheats = function(){
  CHEAT.active=true; CHEAT.noHitboxes=true; CHEAT.speedBoost=500;
  try{ toast('CHEAT: no hitboxes + 500x speed'); }catch{}
  console.info('%cCHEAT ENABLED%c  no-hit + 500x speed','background:#22c55e;color:#04140a;padding:2px 6px;border-radius:6px','');
      return 'CHEAT ENABLED';
    };
    window.disableCheats = function(){
      CHEAT.active=false; CHEAT.noHitboxes=false; CHEAT.speedBoost=1;
      try{ toast('CHEAT disabled'); }catch{}
      console.info('CHEAT disabled');
      return 'CHEAT disabled';
    };
    // convenient alias
    window.cheat = window.enableCheats;
  }catch{}
  })();
  </script>
</body>
</html>
